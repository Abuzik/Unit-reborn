# [Умные указатели](https://doc.rust-lang.ru/book/ch15-00-smart-pointers.html#%D0%A3%D0%BC%D0%BD%D1%8B%D0%B5-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8)

_Указатель_ - это общая концепция для переменной, которая содержит адрес на участок памяти. Этот адрес "относится к", или "указывает на" некоторые другие данные. Наиболее общая разновидность указателя в Rust - это ссылка, о которой вы узнали из Главы 4. Ссылки обозначаются символом `&` и заимствуют значение на которое они указывают. Они не имеют каких-либо специальных возможностей, кроме как ссылаться на данные. Кроме того, они не имеют никаких накладных расходов и являются тем указателем, который мы используем чаще всего.

_Умные указатели_ с другой стороны, являются структурами данных, которые не только действуют как указатель, но также имеют дополнительные метаданные и дополнительные возможности. Концепция умных указателей не уникальна для Rust: умные указатели возникли в C ++ и существуют в других языках. В Rust есть разные умные указатели, определённые в стандартной библиотеке, которые обеспечивают функциональность выходящую за рамки ссылок. Одним из примеров, который мы рассмотрим в этой главе, является тип умного указателя _reference counting_ (подсчёт ссылок). Этот указатель позволяет иметь несколько владельцев данных с помощью отслеживания количества владельцев и очистки данных, когда владельцев не осталось.

В Rust, который использует концепцию владения и заимствования, дополнительная разница между ссылками и умными указателями заключается в том, что ссылки являются указателями, которые только заимствуют данные; против того, что во многих случаях умные указатели _владеют_ данными на которые они указывают.

Мы уже встречали несколько умных указателей в этой книге, таких как `String` и тип `Vec<T>` в главе 8, хотя мы не называли их умными указателями в тот момент. Оба этих типа считаются умными указателями, потому что они владеют некоторой областью памяти и позволяют ею манипулировать. У них также есть метаданные (например, их ёмкость) и дополнительные возможности или гарантии (например, `String` обеспечивает, что содержимое всегда будет действительными данными в кодировке UTF-8).

Умные указатели обычно реализуются с использованием структур. Характерной чертой, которая отличает умный указатель от обычной структуры является то, что для умных указателей реализованы типажи `Deref` и `Drop`. Типаж `Deref` позволяет экземпляру умной структуры указателя вести себя как ссылка, так что вы можете написать код работающий или со ссылками или с умными указателями. Типаж `Drop` позволяет настроить код запускаемый, когда экземпляр умного указателя выходит из области видимости. В этой главе мы обсудим оба типажа и продемонстрируем почему они важны для умных указателей.

Учитывая, что шаблон умный указатель является общим шаблоном проектирования часто используемым в Rust, эта глава не описывает все существующие умные указатели. Множество библиотек имеют свои умные указатели и вы также можете написать свои. Мы охватим наиболее распространённые умные указатели из стандартной библиотеки:

-   `Box<T>` для распределения значений в куче (памяти)
-   `Rc<T>` тип счётчика ссылок, который допускает множественное владение
-   Типы `Ref<T>` и `RefMut<T>`, доступ к которым осуществляется через тип `RefCell<T>`, который обеспечивает правила заимствования во время выполнения, вместо времени компиляции

# [Использование `Box<T>` для ссылки на данные в куче](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-boxt-%D0%B4%D0%BB%D1%8F-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8-%D0%BD%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B2-%D0%BA%D1%83%D1%87%D0%B5)

Наиболее простой умный указатель - это _box_, чей тип записывается как `Box<T>`. Такие переменные позволяют хранить данные в куче, а не в стеке. То, что остаётся в стеке, является указателем на данные в куче. Обратитесь к Главе 4, чтобы рассмотреть разницу между стеком и кучей.

У Box нет проблем с производительностью, кроме хранения данных в куче вместо стека. Но он также и не имеет множества дополнительных возможностей. Вы будете использовать его чаще всего в следующих ситуациях:

-   Если у вас есть тип, размер которого не может быть известен во время компиляции и вы хотите использовать значение этого типа в контексте, который требует точного размера
-   Когда у вас есть большой объем данных и вы хотите передать его во владение, но убедиться, что данные не будут скопированы, когда вы это сделаете
-   Когда вы хотите иметь значение и вам важно только то, что это тип, который реализует конкретный типаж, а не является конкретный типом

## [Использование `Box<T>` для хранения данных в куче](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-boxt-%D0%B4%D0%BB%D1%8F-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B2-%D0%BA%D1%83%D1%87%D0%B5)

Прежде чем мы обсудим этот вариант использования `Box<T>`, мы рассмотрим синтаксис и как взаимодействовать со значениями, хранящимися в `Box<T>`.

В листинге 15-1 показано, как использовать поле для хранения значения `i32` в куче:

Файл: src/main.rs
```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

Мы определяем переменную `b` как имеющую значение типа `Box`, указывающее на значение `5` в куче. Эта программа напечатает `b = 5`; в этом случае мы можем получить доступ к данным в поле, как если бы это были данные в стеке. Как и любое значение во владении, данная память будет освобождена, когда box выйдет из области действия, что происходит с `b`в конце `main`. Освобождается память, занимаемая box (хранится в стеке), и тех данных, на которые он указывает (хранятся в куче).

Размещение единственного значения в куче не очень полезно, поэтому вы не будете часто использовать box сам по себе таким способом. Иметь единственное значение `i32` в стеке, где они хранятся по умолчанию, подходит в большинстве ситуаций. Давайте рассмотрим случай, когда Box позволяет определять типы, которые были бы невозможны, если бы у нас не было Box.

 ## [Включение рекурсивных типов с помощью Boxes](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-boxes)

Во время компиляции Rust должен знать, сколько места занимает тип. Некоторый тип, чей размер не может быть известен во время компиляции, является _рекурсивным типом_ (recursive type), где значение может иметь в своём составе другое значение того же типа. По причине того, что это вложение значений может теоретически продолжаться бесконечно, Rust не знает, сколько пространства памяти необходимо для значений рекурсивного типа. Однако Box имеет известный размер, поэтому используя Box в определении рекурсивного типа, можно его реализовать.

Давайте рассмотрим _cons список_ (cons - функция конструктор, создаёт объекты памяти, которые содержат два значения или указатели на значения), который является распространённым в функциональных языках программирования типом данных, как пример рекурсивного типа. Тип "cons список", который мы определим, является простым, за исключением рекурсии; поэтому концепции, используемые в примере, с которым мы будем работать, будут полезны и в более сложных ситуациях, связанных с рекурсивными типами.

#### [Больше информации о cons списке](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%91%D0%BE%D0%BB%D1%8C%D1%88%D0%B5-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8-%D0%BE-cons-%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B5)

_cons список_ (cons list) - это структура данных, которая пришла из языка программирования Lisp и его диалектов. В Lisp, функция `cons` (сокращение от "construct function" функция-конструктор) создаёт новую пару используя два аргумента, один из которых значение, а другой - пара. Эти пары, содержащие другие пары, образуют список.

Концепция функции конструктора прошла свой путь и превратилась в более общий функциональный, программный жаргон: "to cons _х_ onto _у_" неформально означает создание нового экземпляра контейнера, помещая элемент _х_ в начале нового контейнера, за которым следует контейнер _y_.

Каждый элемент в cons списке содержит два элемента: значение текущего элемента и следующий элемент. Последний элемент в списке содержит только значение называемое `Nil`без следующего элемента. Cons список создаётся путём рекурсивного вызова функции `cons`. Каноничное имя для обозначения базового случая рекурсии - `Nil`. Обратите внимание, что это не то же самое, что понятие “null” или “nil” из главы 6, которая является недействительным или отсутствующим значением.

Хотя функциональные языки программирования часто используют cons списки, этот список не является широко используемой структурой данных в Rust. Большую часть времени, когда есть список элементов в Rust, лучше использовать `Vec<T>`. Более сложные рекурсивные типы данных _являются_ полезными в различных ситуациях, но начиная изучение с cons списка, мы можем исследовать, как box-ы позволяют определить рекурсивный тип данных без особых проблем.

Листинг 15-2 содержит объявление перечисления cons списка. Обратите внимание, что этот код не будет компилироваться, потому что тип `List` не имеет известного размера, что мы и продемонстрируем.

```rust 
enum List {
    Cons(i32, List),
    Nil,
}
```

> Примечание: мы реализуем cons список, который для примера содержит только значения `i32`. Чтобы определить тип cons список для хранения значений любого типа, мы могли бы использовать обобщённые типы, как обсуждалось в главе 10.

Использование типа `List` для хранения списка `1, 2, 3` будет выглядеть как код в листинге 15-3:

```rust 
enum List {
    Cons(i32, List),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

Первое значение `Cons` содержит `1` и другой `List`. Это значение `List` является следующим значением `Cons`, которое содержит `2` и другой `List`. Это значение `List` является ещё один значением `Cons`, которое содержит `3` и значение `List`, которое наконец является `Nil`, не рекурсивным вариантом, сигнализирующим об окончании списка.

Если мы попытаемся скомпилировать код в листинге 15-3, мы получим ошибку, показанную в листинге 15-4:
```markdown
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +

error[E0391]: cycle detected when computing drop-check constraints for `List`
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing drop-check constraints for `List` again
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, value: List } }`

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to 2 previous errors
```
Листинг 15-3: Ошибка, получаемая при попытке определить бесконечное рекурсивное перечисление

Ошибка сообщает, что этот тип "имеет бесконечный размер". Причина в том, что мы определили `List` с рекурсивным вариантом: он содержит другое значение самого себя. В результате Rust не может понять, сколько места ему нужно для хранения значения `List`. Давайте разберёмся, почему мы получаем эту ошибку. Во-первых, давайте посмотрим как Rust решает, сколько места ему нужно для хранения значения нерекурсивного типа.

## [Вычисление размера нерекурсивного типа](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D0%B0-%D0%BD%D0%B5%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0)

Вспомните перечисление `Message` определённое в листинге 6-2, когда обсуждали объявление enum в главе 6:
```rust 
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
Чтобы определить, сколько памяти выделять под значение `Message`, Rust проходит каждый из вариантов, чтобы увидеть, какой вариант требует наибольшее количество памяти. Rust видит, что для `Message::Quit` не требуется места, `Message::Move` хватает места для хранения двух значений `i32` и т.д. Так как будет использоваться только один вариант, то наибольшее пространство, которое потребуется для значения `Message`, это пространство, которое потребуется для хранения самого большого из вариантов перечисления.

Сравните это с тем, что происходит, когда Rust пытается определить, сколько места необходимо рекурсивному типу, такому как перечисление `List` в листинге 15-2. Компилятор смотрит на вариант `Cons`, который содержит значение типа `i32` и значение типа `List`. Следовательно, `Cons` нужно пространство, равное размеру `i32` плюс размер `List`. Чтобы выяснить, сколько памяти необходимо типу `List`, компилятор смотрит на варианты, начиная с `Cons`. Вариант `Cons` содержит значение типа `i32` и значение типа `List`, и этот процесс продолжается бесконечно, как показано на рисунке 15-1.

![slice-link](https://raw.githubusercontent.com/Abuzik/reborn-block/0902656ed67519e912e28df46a30ffd928a6d3c1/Rust-helps/images/8.svg "Slice")

## [Использование `Box<T>` для получения рекурсивного типа с известным размером](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-boxt-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0-%D1%81-%D0%B8%D0%B7%D0%B2%D0%B5%D1%81%D1%82%D0%BD%D1%8B%D0%BC-%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D0%BE%D0%BC)

Rust не может понять, сколько места выделить для типов определённых рекурсивно, поэтому компилятор выдаёт ошибку в листинге 15-4. Но ошибка включает в себя это полезное предложение:
```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```
Листинг 15-5: Определение `List`, которое использует `Box`, чтобы иметь известный размер

Варианту `Cons` понадобится размер `i32` плюс место для хранения данных указателя Box. Вариант `Nil` не хранит значений, поэтому ему нужно меньше места, чем варианту `Cons`. Теперь мы знаем, что любое значение `List` будет занимать размер `i32` плюс размер данных указателя Box. Используя Box, мы сломали бесконечную рекурсивную цепочку, так что компилятор может определить размер, необходимый для хранения значения `List`. На рисунке 15-2 показано как теперь выглядит вариант `Cons`.

![slice-link](https://raw.githubusercontent.com/Abuzik/reborn-block/0902656ed67519e912e28df46a30ffd928a6d3c1/Rust-helps/images/9.svg "Slice")

Рисунок 15-2: `List`, размер которого не безграничен, потому что `Cons` содержит `Box`

Box-ы обеспечивают только косвенность и выделение в куче; у них нет других специальных возможностей, таких как те, которые мы увидим у других типов умных указателей. Они также не имеют накладных расходов из-за этих специальных возможностей, поэтому могут быть полезны в случаях, похожих на cons список, где косвенность - единственная нужная функциональность. Мы рассмотрим ещё больше вариантов использования типа `Box` в главе 17.

Тип `Box<T>` является умным указателем, потому что он реализует типаж `Deref`, что позволяет значениям `Box<T>` обрабатываться как ссылки. Когда значение `Box<T>` выходит из области видимости, то данные кучи, на которые указывает Box, очищаются благодаря реализации типажа `Drop`. Давайте рассмотрим эти два типажа более подробно. Эти два типажа будут ещё более важными для функциональности, предоставляемой другими типами умных указателей, которые мы обсудим в оставшихся частях этой главы.