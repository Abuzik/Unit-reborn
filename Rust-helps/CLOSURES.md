## [Создание обобщённого поведения используя замыкания](https://doc.rust-lang.ru/book/ch13-01-closures.html#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F)

Рассмотрим пример демонстрирующий ситуацию, где сохранение замыкания удобно для его более позднего выполнения. Мы также поговорим про синтаксис замыканий, выведение типов и типажи.

Рассмотрим гипотетическую ситуацию, что мы работаем в стартапе, где создаём приложение для генерации индивидуальных планов тренировок. Серверная часть приложения создаётся на Rust и алгоритм генерирующий план тренировки, учитывает многие различные факторы, такие как возраст пользователя приложения, индекс массы тела, предпочтительные задания, последние тренировки и индекс интенсивности, которые указываются. При проектировании приложения конкретные алгоритмы реализаций не важны. Важно, чтобы различные расчёты не занимали много времени. Мы хотим использовать этот алгоритм только когда нам нужно, и делать это только один раз, чтобы не заставлять пользователя ждать больше, чем требуется.

Мы будем эмулировать работу алгоритма расчёта параметров с помощью функции `simulated_expensive_calculation` листинга 13-1, которая печатает `calculating slowly...`, ждёт две секунды и возвращает любое переданное ему число как результат эмулированного расчёта.
```rust
#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec<ShirtColor>,
}

impl Inventory {
    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&self) -> ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &self.shirts {
            match color {
                ShirtColor::Red => num_red += 1,
                ShirtColor::Blue => num_blue += 1,
            }
        }
        if num_red > num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
```

## [Рефакторинг с помощью замыкания для сохранение кода, который может быть запущен позднее](https://doc.rust-lang.ru/book/ch13-01-closures.html#%D0%A0%D0%B5%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B4%D0%BB%D1%8F-%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9-%D0%BC%D0%BE%D0%B6%D0%B5%D1%82-%D0%B1%D1%8B%D1%82%D1%8C-%D0%B7%D0%B0%D0%BF%D1%83%D1%89%D0%B5%D0%BD-%D0%BF%D0%BE%D0%B7%D0%B4%D0%BD%D0%B5%D0%B5)

Вместо того, чтобы всегда выполнять функцию `simulated_expensive_calculation` перед блоком `if`, мы может определить замыкание и сохранить это _замыкание_ в переменной вместо того, чтобы сохранять результат вызова функции, как показано в листинге 13-5. Можно переместить все тело `simulated_expensive_calculation` в замыкание представленное здесь.

Файл: src/main.rs
```rust
 let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
```
Определение замыкания начинается после символа `=`, который присваивает его переменной `expensive_closure`. Замыкание мы начинаем с пары палочек (vertical pipes (`|`)). Внутри этой конструкции мы определяем входные параметры замыкания. Такой синтаксис был выбран под влиянием языков Ruby и Smalltalk. Данное замыкание имеет параметр `num`. Если нужно несколько параметров, то они разделяются запятыми: `|param1, param2|`.

После параметров замыкания, в фигурных скобках идёт тело функции замыкания. Фигурные скобки могут не использоваться, если код функции состоит только из одной строчки кода. После закрытия фигурных скобок необходим символ `;` для завершения выражения. Значение возвращаемое последней строчкой тела замыкания (`num`) будет являться значением, которое будет возвращено из замыкания, когда оно будет вызвано, поэтому данная строка не содержит точку с запятой (`;`) как и в теле любой функции.

Обратите внимание, что выражение `let` означает, что  `expensive_closure` содержит _определение_ анонимной функции, а не _значение результата_ выполнения анонимной функции. Напомним, что мы используем замыкание, потому что хотим определить код для вызова в одной точке, сохранить этот код и фактически вызвать его на более позднем этапе. Код, который мы хотим вызвать, теперь хранится в переменной `expensive_closure`.

Теперь, после определения замыкания можно изменить код в блоках `if`: вызвать код замыкания чтобы его выполнить и получить результирующее значение. Вызов замыкания очень похож на вызов функции. Мы определяем имя переменной, которая содержит определение замыкания и в скобках указываем аргументы, которые мы хотим использовать для вызова, как показано в листинге 13-6.

```rust
use std::thread;
use std::time::Duration;

fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_closure(intensity));
        println!("Next, do {} situps!", expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_closure(intensity)
            );
        }
    }
}

fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
```

Теперь то, как выполнять дорогостоящие вычисления, определяется только в одном месте, и мы выполняем этот код только там, где нам нужны результаты.

Однако мы повторно представили одну из проблем из листинга 13-3: мы по-прежнему дважды вызываем замыкание в первом `if`блоке, что вызовет дорогостоящий код дважды и заставит пользователя ждать в два раза дольше, чем ему нужно. Мы могли бы решить эту проблему, создав локальную для этого `if`блока переменную для хранения результата вызова замыкания, но замыкания предоставляют нам другое решение. Мы немного поговорим об этом решении. Но сначала давайте поговорим о том, почему в определении замыкания нет аннотаций типов, и о свойствах, связанных с замыканиями.

## [Вывод типа замыкания и аннотация](https://doc.rust-lang.org/book/ch13-01-closures.html#closure-type-inference-and-annotation)

Замыкания не требуют, чтобы вы аннотировали типы параметров или возвращаемое значение, как `fn`это делают функции. Аннотации типов необходимы для функций, поскольку они являются частью явного интерфейса, доступного для ваших пользователей. Жесткое определение этого интерфейса важно для гарантии того, что все согласны с тем, какие типы значений использует и возвращает функция. Но замыкания не используются в открытом интерфейсе, подобном этому: они хранятся в переменных и используются без их именования и предоставления пользователям нашей библиотеки.

Замыкания обычно короткие и актуальны только в узком контексте, а не в произвольном сценарии. В этих ограниченных контекстах компилятор может надежно определить типы параметров и тип возвращаемого значения, подобно тому, как он может определить типы большинства переменных.

Заставлять программистов аннотировать типы в этих маленьких анонимных функциях было бы раздражающим и в значительной степени избыточным с информацией, уже доступной компилятору.

Как и в случае с переменными, мы можем добавить аннотации типов, если хотим повысить четкость и ясность за счет большей детализации, чем это необходимо. Аннотирование типов для замыкания, которое мы определили в листинге 13-5, будет выглядеть как определение, показанное в листинге 13-7.
```rust
 let expensive_closure = |num: u32| -> u32 {
	 println!("calculating slowly..."); 
	 thread::sleep(Duration::from_secs(2)); 
	 num 
};
```
С добавлением аннотаций типов синтаксис замыканий больше похож на синтаксис функций. Ниже приведено вертикальное сравнение синтаксиса определения функции, добавляющей 1 к своему параметру, и замыкания, имеющего такое же поведение. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это иллюстрирует, насколько синтаксис замыкания похож на синтаксис функции, за исключением использования конвейеров и количества необязательных синтаксиса:
```rust
fn add_one_v1 (x: u32) -> u32 { x + 1 } 
let add_one_v2 = |x: u32| -> u32 { x + 1 }; 
let add_one_v3 = |x| { x + 1 }; 
let add_one_v4 = |x| x + 1 ;
```
Определения закрытия будут иметь один конкретный тип, выведенный для каждого из их параметров и для их возвращаемого значения. Например, в листинге 13-8 показано определение короткого замыкания, которое просто возвращает значение, полученное в качестве параметра. Это замыкание не очень полезно, за исключением целей этого примера. Обратите внимание, что мы не добавили никаких аннотаций типов в определение: если мы затем попытаемся вызвать замыкание дважды, используя a `String`в качестве аргумента в первый раз и `u32`во второй раз, мы получим ошибку.

### *Не скомпилируется!*
```rust
let example_closure = |x| x;
let s = example_closure(String::from("hello")); 
let n = example_closure(5);
```
Когда мы в первый раз вызываем `example_closure` со значением типа `String`, компилятор выводит тип для  `x` и возвращаемого значения как `String`. Эти типы затем привязываются к замыканию в `example_closure` и мы получаем ошибку типа, если пытаемся использовать другой тип с тем же замыканием.

## [Сохранение замыканий используя обобщённые типы и типажи `Fn`](https://doc.rust-lang.ru/book/ch13-01-closures.html#%D0%A1%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B9-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-%D0%BE%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B8-%D1%82%D0%B8%D0%BF%D0%B0%D0%B6%D0%B8-fn)

Вернёмся к нашему приложению для создания тренировок. В листинге 13-6 наш код по-прежнему вызывал замыкание с дорогостоящим вычислением больше, чем это требовалось. Один из вариантов решения этой проблемы - сохранить результат дорогостоящего замыкания в переменной для повторного использования и использовать переменную в каждом месте, где нам нужен результат, вместо повторного вызова замыкания. Однако этот метод может привести к многократному повторению кода.

К счастью, нам доступно другое решение. Можно создать структуру, которая будет содержать замыкание и значение вызова замыкания. Структура будет выполнять замыкание только если нам понадобится результирующее значение, а результирующее значение будет кэшировать, поэтому остальной части нашего кода не понадобится отвечать за сохранение и повторное использование результата. Вы можете знать этот шаблон как _memoization (запоминание)_ или _lazy evaluation (ленивое вычисление)_.

Чтобы создать структуру, которая содержит замыкание, нам нужно указать тип замыкания, потому что определение структуры должно описывать типы каждого из его полей. Каждый экземпляр замыкания имеет свой уникальный анонимный тип: то есть, даже если два замыкания имеют одну и ту же сигнатуру, их типы по-прежнему считаются разными. Для определения структур, перечислений или параметров функций, которые используют замыкания, мы используем обобщённые типы и ограничения типажей, как мы обсуждали в Главе 10.

Типажи `Fn` входят в состав стандартной библиотеки. Все замыкания реализуют один из типажей: `Fn`, `FnMut` или `FnOnce`. Мы поговорим о различиях между ними в разделе ["Захват переменных окружения замыканиями"](https://doc.rust-lang.ru/book/ch13-01-closures.html#capturing-the-environment-with-closures); в данном примере мы можем использовать типаж `Fn`.

Мы добавляем типы в описание ограничений типажа `Fn` для описания типов параметров и возвращаемого значения, которое замыкания должны иметь для того, чтобы соответствовать данному ограничению типажа. В данном случае, наше замыкание имеет тип параметра `u32` и возвращает тип `u32`, поэтому сигнатуру ограничения типажа мы описываем как `Fn(u32) -> u32`.

Листинг 13-9 показывает определение структуры `Cacher` содержащей замыкание и необязательное значение результата:
```rust
struct Cacher<T> 
where 
T: Fn(u32) -> u32, 
{ 
	calculation: T, 
	value: Option<u32>, 
}
```
Структура `Cacher` имеет поле `calculation` обобщённого типа `T`. Ограничение типажа для `T`требует, чтобы обобщённый тип соответствовал замыканию: требование определяется типажом `Fn`. Любое замыкание, которые мы хотим сохранить в поле `calculation` должно иметь один параметр типа  `u32` (указанный внутри круглых скобок после `Fn`) и должно возвращать тип `u32` (указанный после `->`).
> Примечание. Функции также могут реализовывать все три типажа `Fn`. Если то, что мы хотим сделать, не требует захвата значения из среды, мы можем использовать функцию, а не замыкание, где нам нужно что-то, что реализует типаж `Fn`.
Поле `value`имеет тип `Option<u32>`. Прежде чем мы выполним закрытие, `value`будет `None`. Когда код, использующий a, `Cacher`запрашивает _результат_ закрытия, `Cacher`он выполнит закрытие в это время и сохранит результат в `Some`варианте в `value`поле. Затем, если код снова запрашивает результат закрытия, вместо повторного выполнения закрытия `Cacher`вернет результат, хранящийся в `Some`варианте.

Логика `value`поля, которое мы только что описали, определена в листинге 13.10.

Имя файла: src/main.rs
```rust
impl<T> Cacher<T> 
where 
T: Fn(u32) -> u32, 
{ 
	fn new(calculation: T) -> Cacher<T> 
	{ 
		Cacher 
		{ 
			calculation, 
			value: None, 
		} 
	} 
	fn value(&mut self, arg: u32) -> u32 { 
		match self.value { 
			Some(v) => v, 
			None => { 
				let v = (self.calculation)(arg); 
				self.value = Some(v); 
				v 
			} 
		}
	} 
}
```
Вместо непосредственного сохранения замыкания в переменной мы сохраняем новый экземпляр `Cacher`, который содержит замыкание. Затем в каждом месте, где мы хотим получить результат, мы вызываем метод `value` у экземпляра `Cacher`. Мы можем вызывать метод `value` столько раз, сколько захотим или не вызывать его вообще, а дорогостоящие вычисления будут выполняться максимум один раз.

Попробуйте запустить эту программу с помощью функции `main` из листинга 13-2. Измените значения в переменных `simulated_user_specified_value` и `simulated_random_number`, чтобы убедиться, что во всех случаях в различных блоках `if` и `else` текст `calculating slowly...`появляется только один раз и только при необходимости. `Cacher` заботится о логике, необходимой для обеспечения того, чтобы мы не вызывали дорогостоящие вычисления больше, чем нужно, чтобы мы могли сосредоточиться на бизнес-логике в `generate_workout`.

## [Ограничения реализации `Cacher`](https://doc.rust-lang.ru/book/ch13-01-closures.html#%D0%9E%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-cacher)

Кэширование значений - это обычно полезное поведение, которое мы могли бы использовать в других частях нашего кода с другими замыканиями. Однако в текущей реализации `Cacher` есть две проблемы, которые затрудняют его повторное использование в различных контекстах.

Первая проблема заключается в том, что экземпляр `Cacher` предполагает, что он всегда получит одно и то же значение параметра `arg` для метода `value`. То есть этот тест `Cacher` не пройдёт:
```rust
    #[test]
    fn call_with_different_values() {
        let mut c = Cacher::new(|a| a);

        let v1 = c.value(1);
        let v2 = c.value(2);

        assert_eq!(v2, 2);
    }
```
Этот тест создает новый `Cacher`экземпляр с замыканием, которое возвращает переданное ему значение. Мы вызываем `value`метод для этого `Cacher`экземпляра со `arg`значением 1, а затем со `arg`значением 2, и мы ожидаем, что вызов `value`со `arg`значением 2 вернет 2.

Запустите этот тест с `Cacher`реализацией в листинге 13-9 и листинге 13-10, и тест завершится ошибкой `assert_eq!`с этим сообщением:
```markdown
$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/cacher-074d7c200c000afa)

running 1 test
test tests::call_with_different_values ... FAILED

failures:

---- tests::call_with_different_values stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::call_with_different_values

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
Проблема в том, что при первом вызове `c.value`с 1 `Cacher` экземпляр, сохраненный `Some(1)`в `self.value`. После этого, независимо от того, что мы передаем в `value`метод, он всегда будет возвращать 1.

Попробуйте изменить `Cacher`, чтобы удерживать хеш-карту, а не одно значение. Ключи хэш-карты будут `arg`переданными значениями, а значения хэш-карты будут результатом вызова замыкания для этого ключа. Вместо того, чтобы смотреть, `self.value`имеет ли непосредственно значение `Some`или `None`, `value`функция будет искать `arg`в хеш-карте и возвращать значение, если оно присутствует. Если его нет, `Cacher`вызовет замыкание и сохранит полученное значение в хэш-карте, связанной с его `arg`значением.

Вторая проблема с текущей `Cacher`реализацией заключается в том, что она принимает только замыкания, которые принимают один параметр типа `u32`и возвращают `u32`. `usize`Например, мы можем захотеть кэшировать результаты замыканий, которые берут срез строки и возвращают значения. Чтобы решить эту проблему, попробуйте ввести более общие параметры, чтобы повысить гибкость `Cacher`функциональности.

## [Захват переменных окружения с помощью замыкания](https://doc.rust-lang.ru/book/ch13-01-closures.html#%D0%97%D0%B0%D1%85%D0%B2%D0%B0%D1%82-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F)

В примере генератора тренировок мы использовали только замыкания в качестве встроенных анонимных функций. Однако у замыканий есть дополнительная возможность, которой нет у функций: они могут захватывать своё окружение и получать доступ к переменным из области видимости, в которой они определены.

В листинге 13-12 приведён пример замыкания, хранящегося в переменной `equal_to_x`, в которой используется переменная `x` из ближайшего окружения замыкания.

Файл: src/main.rs

Имя файла: src/main.rs
```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```
Здесь, несмотря на то, что `x`это не один из параметров `equal_to_x`, `equal_to_x`замыкание может использовать `x`переменную, определенную в той же области, что `equal_to_x`и в . Мы не можем сделать то же самое с функциями;

В случае когда замыкание захватывает значение из своего окружения, оно использует дополнительную память для хранения значений используемых в теле замыкания. Такое использование памяти является накладными расходами, которые мы не хотим платить в общих случаях, там где мы хотим выполнить код, который не захватывает переменные окружения. Поскольку функциям никогда не разрешается захватывать их окружение, то определение и использование функций никогда не повлечёт за собой таких издержек.

Замыкания могут захватывать значения из своего окружения тремя способами, которые напрямую соответствуют трём способам, которыми функция может принимать параметр: забирать во владение, получать изменяемое заимствование и получать неизменяемое заимствование. Эти способы закодированы в трёх типажах `Fn` следующим образом:

-   замыкания типажа `FnOnce` потребляют переменные, которые они захватывают из окружающего контекста, известного как _окружение (environment)_ замыкания. Чтобы использовать захваченные переменные, замыкание должно стать владельцем этих переменных и переместить их в замыкание, когда оно определено. Часть имени `Once`отражает тот факт, что замыкание не может владеть одними и теми же переменными более одного раза, поэтому его можно вызывать только один раз.
-   замыкания типажа `FnMut` могут изменять значения переменных из окружения, поскольку они заимствуют изменяемые значения.
-   замыкания типажа `Fn` заимствуют значения из окружения без их изменения.

Когда вы создаёте замыкание Rust определяет какой типаж использовать, основываясь на том как замыкание использует значения из окружения. Все замыкания реализуют `FnOnce`, потому что все они могут быть вызваны хотя бы один раз. Замыкания, которые не перемещают захваченные переменные, также реализуют `FnMut`, а замыкания которым не требуется изменяемый доступ к захваченным переменным, также реализуют `Fn`. В листинге 13-12 замыкание `equal_to_x` заимствует `x` как неизменяемый (поэтому `equal_to_x` имеет типаж `Fn`), поскольку тело замыкания должно только читать значение в `x`.

Если вы хотите, чтобы замыкание стало владельцем значений, которые оно использует в окружении, то вы можете использовать ключевое слово `move` перед списком параметров. Этот метод в основном полезен при передаче замыкания в новый поток для перемещения данных, чтобы они принадлежали новому потоку.

> Примечание: замыкания с `move` могут по-прежнему реализовывать `Fn` или `FnMut`, даже если они захватывают переменные при перемещении. Это связано с тем, что типаж, реализуемый типом замыкания, определяется тем, что замыкание делает с захваченными значениями, а не тем, как оно их захватывает. Ключевое слово `move`указывает только как замыкание захватывает значения.

## [Обработка группы элементов с помощью итераторов](https://doc.rust-lang.ru/book/ch13-02-iterators.html#%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D1%8B-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2)

Шаблон итератора позволяет выполнять некоторые задачи над последовательностью элементов. Итератор отвечает за логику итерации по каждому элементу и определяет, когда последовательность завершилась. Когда вы используете итераторы, вам не нужно переопределять эту логику самостоятельно.

Итераторы В Rust _ленивы_, то есть они не делают ничего, пока вы не вызовете методы, которые потребляют итератор. Например, код в листинге 13-13 создаёт итератор по элементам вектора `v1`, вызывая метод `iter`, определённый для `Vec<T>`. Сам по себе этот код не делает ничего полезного.
```rust
let v1 = vec![1, 2, 3]; 
let v1_iter = v1.iter();
```
Создав итератор, можно использовать его различными способами. В листинге 3-5 главы 3 мы использовали итераторы с циклами `for`, чтобы выполнить некоторый код для каждого элемента, хотя только вкратце останавливались на том, что делал вызов `iter` до этих пор.

Пример в листинге 13-14 отделяет создание итератора от его использования в цикле `for`. Итератор хранится в переменной `v1_iter`, и в это время итерация не выполняется. Когда цикл `for` вызывается с использованием итератора `v1_iter`, каждый элемент итератора используется в одной итерации цикла, которая выводит значение этого элемента.
```rust
fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {}", val);
    }
}
```
В языках, которые не имеют итераторов в стандартной библиотеке, вы, вероятно, написали бы эту же функцию следующим образом: взять переменную со значением 0, использовать её для индексации вектора, чтобы получить значение, и увеличивать её значение в цикле, пока не будет достигнуто общее количество элементов в векторе.

Итераторы делают все эти шаги за вас, сокращая повторяющийся код, который вы потенциально могли бы испортить. Итераторы дают вам больше гибкости для использования одной и той же логики с различными типами последовательностей, а не только со структурами данных, которые можно индексировать, типа векторов. Давайте посмотрим как итераторы это делают.

## [Типаж `Iterator` и метод `next`](https://doc.rust-lang.ru/book/ch13-02-iterators.html#%D0%A2%D0%B8%D0%BF%D0%B0%D0%B6-iterator-%D0%B8-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-next)

Все итераторы реализуют типаж `Iterator`, который определён в стандартной библиотеке. Его определение выглядит так:
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```
Обратите внимание данное объявление использует новый синтаксис: `type Item` и `Self::Item`, которые определяют _ассоциированный тип_ (associated type) с этим типажом. Мы подробнее поговорим о ассоциированных типах в главе 19. Сейчас вам нужно знать, что этот код требует от реализаций типажа `Iterator` определить требуемый им тип `Item` и данный тип `Item` используется в методе `next`. Другими словами, тип `Item` будет являться типом элемента, который возвращает итератор.

Типаж `Iterator` требует, чтобы разработчики определяли только один метод: метод `next`, который возвращает один элемент итератора за раз обёрнутый в вариант `Some` и когда итерация завершена, возвращает `None`.

Мы можем вызвать у итераторов метод `next` напрямую; В листинге 13-15 показано, какие значения возвращаются в результате повторных вызовов `next` на итераторе, созданном из вектора.

```rust
  
pub trait Iterator { 
	type Item; 
	fn next(&mut self) -> Option<Self::Item>; 
	// methods with default implementations elided 
}
```
## [Методы, которые потребляют итератор](https://doc.rust-lang.ru/book/ch13-02-iterators.html#%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%BF%D0%BE%D1%82%D1%80%D0%B5%D0%B1%D0%BB%D1%8F%D1%8E%D1%82-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80)

У типажа `Iterator` есть несколько методов, реализация которых по умолчанию предоставляется стандартной библиотекой; вы можете узнать об этих методах, просмотрев документацию API стандартной библиотеки для `Iterator`. Некоторые из этих методов вызывают `next` в своём определении, поэтому вам необходимо реализовать метод `next` при реализации типажа `Iterator`.

Методы, вызывающие `next`, называются потребляющими адаптерами (_consuming adaptors_), поскольку их вызов использует итератор. Примером потребляющего адаптера является метод `sum`. Он становится владельцем итератора и перемещается по элементам, многократно вызывая `next`, тем самым потребляя итератор. Он выполняет итерацию для каждого элемента и добавляет его к промежуточной сумме, возвращая итоговую сумму после завершения итерации. В листинге 13-16 есть тест, иллюстрирующий использование `sum`:
```rust
fn iterator_sum() {
	let v1 = vec![1, 2, 3]; 
	let v1_iter = v1.iter(); 
	let total: i32 = v1_iter.sum();
	assert_eq!(total, 6); 
}
```
Мы не можем использовать `v1_iter` после вызова метода `sum`, потому что `sum` забирает по владение итератор у которого вызван метод.
## [Методы, которые создают другие итераторы](https://doc.rust-lang.ru/book/ch13-02-iterators.html#%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D1%8E%D1%82-%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B)

Другие методы, определённые в `Iterator`, известные как _адаптеры итераторов (iterator adaptors)_, позволяют преобразовывать в разные виды итераторов. Вы можете связать в последовательность несколько вызовов адаптеров итераторов для выполнения сложных действий в удобном виде. Но поскольку все итераторы ленивы, вы должны вызвать один из потребляющих методов, чтобы получить результат работы цепочки адаптеров.

В листинге 13-17 показан пример использования адаптера `map`, который требует замыкание, чтобы применить его к каждому элементу и создать новый итератор. Замыкание здесь создаёт новый итератор, в котором каждый элемент вектора был увеличен на 1. Однако этот код выдаёт предупреждение:
```rust
let v1: Vec<i32> = vec![1, 2, 3]; 
v1.iter().map(|x| x + 1);
```
Код в листинге 13-17 ничего не делает; замыкание никогда не вызывается. Предупреждение напоминает нам, почему это так: адаптеры итераторов ленивы и мы должны поглотить итератор чтобы увидеть результат.

Чтобы исправить это и поглотить итератор, мы воспользуемся методом `collect`, который мы уже использовали в главе 12 с `env::args` в листинге 12-1. Этот метод использует итератор и собирает полученные значения в коллекцию указанного типа.

В листинге 13-18 мы собираем результаты итерации по итератору, который возвращается из вызова `map` в вектор. Этот вектор будет содержать каждый элемент из исходного вектора, увеличенный на 1.

Файл: src/main.rs
```rust
let v1: Vec<i32> = vec![1, 2, 3]; 
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect(); 
assert_eq!(v2, vec![2, 3, 4]);
```
Листинг 13-18: Вызов метода `map` для создания нового итератора и затем вызов метода `collect` для создания и использования нового итератора, чтобы создать новый вектор с данными

Поскольку `map` принимает замыкание, мы можем указать любую операцию, которую хотим выполнить с каждым элементом. Это отличный пример того, как замыкания позволяют настраивать какое-то поведение при повторном использовании итерационного поведения, предоставляемого типажом `Iterator` .

## [Использование замыканий, которые захватывают переменные окружения](https://doc.rust-lang.ru/book/ch13-02-iterators.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B9-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B7%D0%B0%D1%85%D0%B2%D0%B0%D1%82%D1%8B%D0%B2%D0%B0%D1%8E%D1%82-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)

Теперь, когда мы представили итераторы, мы можем продемонстрировать общее использование замыканий, которые захватывают их окружение используя адаптер итератора `filter`. Метод `filter` в итераторе принимает замыкание, которое берет каждый элемент из итератора и возвращает логическое значение. Если замыкание возвращает `true`, значение будет включено в итератор, созданный методом `filter`. Если замыкание возвращает `false`, значение не будет включено в итоговый итератор.

В листинге 13-19 мы используем метод `filter` с замыканием, которое захватывает переменную `shoe_size` из своего окружения, чтобы выполнить итерацию по коллекции экземпляров структуры `Shoe`. Он вернёт только ту обувь, которая имеет указанный размер.

Файл: src/lib.rs
```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}
```
Функция `shoes_in_size` принимает в качестве параметров вектор с экземплярами обуви и размер обуви, а возвращает вектор, содержащий только обувь указанного размера.

В теле `shoes_in_my_size` мы вызываем `into_iter` чтобы создать итератор, который становится владельцем вектора. Затем мы вызываем `filter`, чтобы превратить этот итератор в другой, который содержит только элементы, для которых замыкание возвращает `true`.

Замыкание захватывает параметр `shoe_size` из окружения и сравнивает его с размером каждой пары обуви, оставляя только обувь указанного размера. Наконец, вызов `collect`собирает значения, возвращаемые адаптированным итератором, в вектор, возвращаемый функцией.

Тест показывает, что когда мы вызываем `shoes_in_my_size`, мы возвращаем только туфли, размер которых совпадает с указанным нами значением.

## [Создание собственных итераторов с помощью типажа `Iterator`](https://doc.rust-lang.ru/book/ch13-02-iterators.html#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D1%82%D0%B8%D0%BF%D0%B0%D0%B6%D0%B0-iterator)

Мы показали, что можно создать итератор из вектора, вызвав `iter`, `into_iter` или `iter_mut`. Вы можете создавать итераторы из других типов коллекций в стандартной библиотеке, таких как хэш-таблица. Вы также можете создавать итераторы, которые делают все, что захотите, реализуя типаж `Iterator` для собственных типов. Как упоминалось ранее, единственный метод, который требуется реализовать, - это `next`. Как только вы это сделаете, вы сможете использовать все другие методы, реализация по умолчанию которых предоставляется `Iterator`!

Чтобы продемонстрировать это, давайте создадим итератор, который будет считать только от 1 до 5. Сначала мы создадим структуру для хранения некоторых значений. Затем мы превратим эту структуру в итератор, реализовав для неё типаж `Iterator` и будем использовать её значения в итераторе.

Листинг 13-20 определяет структуру `Counter` и ассоциированную функцию `new`, создающую экземпляры структуры `Counter`:
```rust
struct Counter { 
	count: u32, 
} 
impl Counter { 
	fn new() -> Counter { 
		Counter { count: 0 } 
	} 
}
```
Листинг 13-20. Определение структуры `Counter` и функции `new`, которая создаёт экземпляры `Counter` с начальным значением 0 для `count`

Структура `Counter` имеет одно поле с именем `count`. Это поле содержит значение `u32`, которое будет отслеживать, где мы находимся в процессе итерации от 1 до 5. Поле `count`является приватным, потому что мы хотим, чтобы реализация `Counter` управляла его значением. Функция `new` обеспечивает такое поведение, чтобы новые экземпляры создавались со значением 0 в поле `count` .

Далее, мы реализуем типаж `Iterator` для структуры `Counter`, определив тело метода `next`, реализуя то, что хотим получить при использовании этого итератора, как это показано в листинге 13-21:

Файл: src/lib.rs
```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

```
Мы указываем связанный тип `Item` для нашего итератора как `u32`, то есть итератор возвращает значения `u32`. Опять же, пока не беспокойтесь о ассоциированных типах, мы рассмотрим их в главе 19.

Мы хотим, чтобы наш итератор прибавил 1 к текущему состоянию, поэтому мы инициализировали `count` равным 0, чтобы он сначала возвращал 1. Если значение `count`меньше 5, `next` будет увеличивать `count` и возвращать текущее значение, обёрнутое в `Some`. Как только `count` станет 5, наш итератор перестанет увеличивать `count` и всегда будет возвращать `None`.

## [Использование у `Counter` метода итератора `next`](https://doc.rust-lang.ru/book/ch13-02-iterators.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%83-counter-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0-next)

Как только мы реализовали типаж `Iterator`, у нас есть итератор! В листинге 13-22 показан тест, демонстрирующий, что мы можем использовать функциональные возможности итератора нашей структуры `Counter`, напрямую вызывая на ней метод `next`, точно так же, как мы это делали с итератором, созданным из вектора в листинге 13-15.

Файл: src/lib.rs
```rust
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }
```
Тест создаёт экземпляр структуры `Counter` в переменной `counter`, затем последовательно вызывает метод `next`, проверяя реализацию необходимого поведения итератора: возвращение чисел от 1 до 5.
## [Использование других методов типажа `Iterator`](https://doc.rust-lang.ru/book/ch13-02-iterators.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D1%85-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2-%D1%82%D0%B8%D0%BF%D0%B0%D0%B6%D0%B0-iterator)

Мы реализовали типаж `Iterator`, написав метод `next`, и можем использовать любые методы `Iterator` для которых в стандартной библиотеке есть реализация по умолчанию, поскольку все они используют функционал метода `next`.

Например, если по какой-то причине мы хотели взять значения, созданные экземпляром `Counter`, сопоставить их со значениями, созданными другим экземпляром `Counter` пропуская первое значение, перемножить каждую пару друг с другом, сохраняя только те результаты, которые делятся на 3 и складывая все полученные значения вместе, мы могли бы сделать это так, как показано в тесте листинга 13-23:

Файл: src/lib.rs

```rust
    fn using_other_iterator_trait_methods() {
        let sum: u32 = Counter::new()
            .zip(Counter::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, sum);
    }

```

## [Удаление метода `clone` используя итератор](https://doc.rust-lang.ru/book/ch13-03-improving-our-io-project.html#%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0-clone-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80)

В листинге 12-6 мы добавили код, который использовал срез  `String` и создал экземпляр структуры `Config`, взяв по индексам данные из среза и клонировав эти значения, таким образом позволив структуре `Config` владеть значениями. В листинге 13-24 мы повторили реализацию функции `Config::new`, как это было в листинге 12-23:

Файл: src/lib.rs
```rust
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            filename,
            ignore_case,
        })
    }
}
```

Ранее мы говорили, что не стоит беспокоиться о неэффективных вызовах `clone`, потому что мы удалим их в будущем. Ну что же, это время пришло!

Нам был нужен вызов `clone` потому что у нас есть срез с элементами `String` в параметре `args`, но функция `new` не владеет `args`. Чтобы вернуть владение экземпляром `Config`, нам пришлось клонировать значения из полей `query` и `filename` структуры `Config`, поэтому экземпляр `Config` может владеть своими значениями.

Обладая новыми знаниями об итераторах, мы можем изменить функцию `new`, чтобы она стала владельцем итератора аргумента, а не заимствовала срез. Мы будем использовать функциональность итератора вместо кода, который проверяет длину среза и получает данные по индексу. Это делает более понятным, что выполняет функция `Config::new`, потому что итератор получит доступ к значениям.

Как только `Config::new` заберёт во владение итератор и перестанет использовать заимствующие операции индексирования, мы можем переместить значения `String` из итератора в `Config` вместо вызова `clone` и выполнения нового выделения памяти.

#### [Использование возвращённого итератора напрямую](https://doc.rust-lang.ru/book/ch13-03-improving-our-io-project.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0%D0%BF%D1%80%D1%8F%D0%BC%D1%83%D1%8E)

Откройте файл _src/main.rs_ проекта ввода-вывода, который должен выглядеть следующим образом:
```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });
}
```
Мы изменим начало функции `main`, которая была в листинге 12-24, на код из листинга 13-25. Он не компилируется, пока мы не обновим `Config::new`.

Файл: src/main.rs
```rust
fn main() { 
	let config = Config::new(env::args()).unwrap_or_else(|err| { 
		eprintln!("Problem parsing arguments: {}", err); 
		process::exit(1); 
	}); // --snip-- 
}
```
Функция `env::args` возвращает итератор! Вместо того, чтобы собирать значения итератора в вектор и затем передавать срез в `Config::new`, мы напрямую передаём во владение итератор, возвращённый из `env::args` параметром в `Config::new`.

Далее нам нужно обновить определение `Config::new`. В файле _src/lib.rs_ вашего проекта ввода/вывода давайте изменим сигнатуру `Config::new` как показано в листинге 13-26. Код все равно ещё не компилируется, потому что нам нужно обновить тело функции.

Файл: src/lib.rs
```rust
impl Config { pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
```
Документация стандартной библиотеки для функции `env::args` показывает, что типом возвращаемого итератора является `std::env::Args`. Мы обновили сигнатуру функции `Config::new`, поэтому параметр `args` имеет тип `std::env::Args` вместо `&[String]`. Поскольку мы забираем во владение `args` и будем изменять `args` перебирая его элементы, мы можем добавить ключевое слово `mut` в спецификацию параметра `args`, чтобы сделать его изменяемым.
#### [Использование методов типажа `Iterator` вместо индексов](https://doc.rust-lang.ru/book/ch13-03-improving-our-io-project.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2-%D1%82%D0%B8%D0%BF%D0%B0%D0%B6%D0%B0-iterator-%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BE-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2)

Далее мы вносим изменения в код тела `Config::new`. Стандартная библиотека документации также упоминает, что `std::env::Args` реализует типаж `Iterator`, поэтому мы знаем, что можем вызвать метод `next`! Листинг 13-27 обновляет код из листинга 12-23 с использованием метода `next`:

Файл: src/lib.rs
```rust
impl Config {
    pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
        args.next();

        let query = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a query string"),
        };

        let filename = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a file name"),
        };

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config {
            query,
            filename,
            case_sensitive,
        })
    }
}
```
Помните, что первое значение в возвращаемом значении типа `env::args` это имя программы. Мы хотим игнорировать его и перейти к следующему значению, поэтому сначала мы вызываем `next` и ничего не делаем с возвращаемым значением. Во-вторых, мы вызываем `next`, чтобы получить значение, которое мы хотим поместить в поле `query` структуры `Config`. Если `next` возвращает `Some`, мы используем `match` для извлечения значения. Если он возвращает `None`, это означает, что было передано недостаточно аргументов и мы сразу же выходим со значением `Err`. Мы делаем то же самое для значения `filename`.
### [Делаем код понятнее с помощью адаптеров итераторов](https://doc.rust-lang.ru/book/ch13-03-improving-our-io-project.html#%D0%94%D0%B5%D0%BB%D0%B0%D0%B5%D0%BC-%D0%BA%D0%BE%D0%B4-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%BD%D0%B5%D0%B5-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%B0%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80%D0%BE%D0%B2-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2)

Мы также можем использовать преимущества итераторов в функции `search` в проекте ввода/вывода, который приводится здесь в листинге 13-28, как это было в листинге 12-19:

Файл: src/lib.rs
```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```
Листинг 13-28: Реализация функции `search` из листинга 12-19

Мы можем написать этот код более кратко, используя адаптерные методы итератора. Это также позволяет нам избежать использования изменяемого промежуточного вектора `result`. Стиль функционального программирования предпочитает минимизировать количество изменяемых состояний, чтобы сделать код более понятным. Удаление изменяемого состояния может позволить в будущем усовершенствовать и сделать поиск параллельным, потому что нам не нужно управлять одновременным доступом к вектору `results`. Листинг 13-29 показывает это изменение:
```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
```

## [Сравнение производительности циклов и итераторов](https://doc.rust-lang.ru/book/ch13-04-performance.html#%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%B2-%D0%B8-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2)

Чтобы определить, что лучше использовать циклы или итераторы, нужно знать, какая реализация быстрее: версия функции `search` с явным циклом `for` или версия с итераторами.

Мы выполнили тест производительности, разместив всё содержимое книги _(“The Adventures of Sherlock Holmes” by Sir Arthur Conan Doyle)_ в строку типа `String` и поискали слово _the_ в её содержимом. Вот результаты теста функции `search` с использованием цикла `for` и с использованием итераторов:
```
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```
Версия с использованием итераторов была немного быстрее! Мы не будем приводить здесь непосредственно код теста, поскольку идея не в том, чтобы доказать, что решения в точности эквивалентны, а в том, чтобы получить общее представление о том, как эти две реализации близки по производительности.

Для более исчерпывающего теста, вам нужно проверить различные тексты разных размеров в качестве содержимого для `contents`, разные слова и слова различной длины в качестве `query` и всевозможные другие варианты. Дело в том, что итераторы, будучи высокоуровневой абстракцией, компилируются примерно в тот же код, как если бы вы написали его низкоуровневый вариант самостоятельно. Итераторы - это одна из _абстракций с нулевой стоимостью_ ( zero-cost abstractions ) в Rust, под которой мы подразумеваем, что использование абстракции не накладывает дополнительных расходов во время выполнения. Аналогично тому, как Бьёрн Страуструп, дизайнер и разработчик C++, определяет _нулевые накладные расходы_ ( zero-overhead ) в книге “Foundations of C++” (2012):

> В целом, реализация C++ подчиняется принципу отсутствия накладных расходов: за то, чем вы не пользуетесь, платить не нужно. И далее: тот код, что вы используете, нельзя сделать ещё лучше.

В качестве другого примера приведём код, взятый из аудио декодера. Алгоритм декодирования использует математическую операцию линейного предсказания для оценки будущих значений на основе линейной функции предыдущих выборок. Код использует комбинирование вызовов итератора для выполнения математических вычислений для трёх переменных в области видимости: срез данных `buffer`, массив из 12 коэффициентов `coefficients` и число для сдвига данных в переменной `qlp_shift`. Переменные определены в примере, но не имеют начальных значений. Хотя этот код не имеет большого значения вне контекста, он является кратким, реальным примером того, как Rust переводит идеи высокого уровня в код низкого уровня.
```rust
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```
Чтобы вычислить значение переменной `prediction`, этот код перебирает каждое из 12 значений в переменной `coefficients` и использует метод `zip` для объединения значений коэффициентов с предыдущими 12 значениями в переменной `buffer`. Затем, для каждой пары мы перемножаем значения, суммируем все результаты и у суммы сдвигаем биты вправо в переменную `qlp_shift`.

Для вычислений в таких приложениях, как аудио декодеры, часто требуется производительность. Здесь мы создаём итератор, используя два адаптера, впоследствии потребляющих значение. В какой ассемблерный код будет компилироваться этот код на Rust? На момент написания этой главы он компилируется в то же самое, что вы написали бы руками. Не существует цикла, соответствующего итерации по значениям в «коэффициентах»`coefficients`: Rust знает, что существует двенадцать итераций, поэтому он «разворачивает» цикл. _Разворачивание_ - это оптимизация, которая устраняет издержки кода управления циклом и вместо этого генерирует повторяющийся код для каждой итерации цикла.

Все коэффициенты сохраняются в регистрах, что означает очень быстрый доступ к значениям. Нет никаких проверок границ доступа к массиву во время выполнения. Все эти оптимизации, которые может применить Rust, делают полученный код чрезвычайно эффективным. Теперь, когда вы это знаете, используйте итераторы и замыкания без страха! Они представляют код в более высокоуровневом виде, но без потери производительности во время выполнения.

## [Итоги](https://doc.rust-lang.ru/book/ch13-04-performance.html#%D0%98%D1%82%D0%BE%D0%B3%D0%B8)

Замыкания (closures) и итераторы (iterators) это возможности Rust, вдохновлённые идеями функциональных языков. Они позволяют Rust ясно выражать идеи высокого уровня с производительностью низкоуровневого кода. Реализации замыканий и итераторов таковы, что нет влияния на производительность выполнения кода. Это одна из целей Rust, направленных на обеспечение абстракций с нулевой стоимостью (zero-cost abstractions).

Теперь, когда мы улучшили представление кода в нашем проекте, рассмотрим некоторые возможности, которые нам предоставляет `cargo` для публикации нашего кода в репозитории.