## [Создание обобщённого поведения используя замыкания](https://doc.rust-lang.ru/book/ch13-01-closures.html#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F)

Рассмотрим пример демонстрирующий ситуацию, где сохранение замыкания удобно для его более позднего выполнения. Мы также поговорим про синтаксис замыканий, выведение типов и типажи.

Рассмотрим гипотетическую ситуацию, что мы работаем в стартапе, где создаём приложение для генерации индивидуальных планов тренировок. Серверная часть приложения создаётся на Rust и алгоритм генерирующий план тренировки, учитывает многие различные факторы, такие как возраст пользователя приложения, индекс массы тела, предпочтительные задания, последние тренировки и индекс интенсивности, которые указываются. При проектировании приложения конкретные алгоритмы реализаций не важны. Важно, чтобы различные расчёты не занимали много времени. Мы хотим использовать этот алгоритм только когда нам нужно, и делать это только один раз, чтобы не заставлять пользователя ждать больше, чем требуется.

Мы будем эмулировать работу алгоритма расчёта параметров с помощью функции `simulated_expensive_calculation` листинга 13-1, которая печатает `calculating slowly...`, ждёт две секунды и возвращает любое переданное ему число как результат эмулированного расчёта.
```rust
#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec<ShirtColor>,
}

impl Inventory {
    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&self) -> ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &self.shirts {
            match color {
                ShirtColor::Red => num_red += 1,
                ShirtColor::Blue => num_blue += 1,
            }
        }
        if num_red > num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
```

## [Рефакторинг с помощью замыкания для сохранение кода, который может быть запущен позднее](https://doc.rust-lang.ru/book/ch13-01-closures.html#%D0%A0%D0%B5%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B4%D0%BB%D1%8F-%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9-%D0%BC%D0%BE%D0%B6%D0%B5%D1%82-%D0%B1%D1%8B%D1%82%D1%8C-%D0%B7%D0%B0%D0%BF%D1%83%D1%89%D0%B5%D0%BD-%D0%BF%D0%BE%D0%B7%D0%B4%D0%BD%D0%B5%D0%B5)

Вместо того, чтобы всегда выполнять функцию `simulated_expensive_calculation` перед блоком `if`, мы может определить замыкание и сохранить это _замыкание_ в переменной вместо того, чтобы сохранять результат вызова функции, как показано в листинге 13-5. Можно переместить все тело `simulated_expensive_calculation` в замыкание представленное здесь.

Файл: src/main.rs
```rust
 let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
```
Определение замыкания начинается после символа `=`, который присваивает его переменной `expensive_closure`. Замыкание мы начинаем с пары палочек (vertical pipes (`|`)). Внутри этой конструкции мы определяем входные параметры замыкания. Такой синтаксис был выбран под влиянием языков Ruby и Smalltalk. Данное замыкание имеет параметр `num`. Если нужно несколько параметров, то они разделяются запятыми: `|param1, param2|`.

После параметров замыкания, в фигурных скобках идёт тело функции замыкания. Фигурные скобки могут не использоваться, если код функции состоит только из одной строчки кода. После закрытия фигурных скобок необходим символ `;` для завершения выражения. Значение возвращаемое последней строчкой тела замыкания (`num`) будет являться значением, которое будет возвращено из замыкания, когда оно будет вызвано, поэтому данная строка не содержит точку с запятой (`;`) как и в теле любой функции.

Обратите внимание, что выражение `let` означает, что  `expensive_closure` содержит _определение_ анонимной функции, а не _значение результата_ выполнения анонимной функции. Напомним, что мы используем замыкание, потому что хотим определить код для вызова в одной точке, сохранить этот код и фактически вызвать его на более позднем этапе. Код, который мы хотим вызвать, теперь хранится в переменной `expensive_closure`.

Теперь, после определения замыкания можно изменить код в блоках `if`: вызвать код замыкания чтобы его выполнить и получить результирующее значение. Вызов замыкания очень похож на вызов функции. Мы определяем имя переменной, которая содержит определение замыкания и в скобках указываем аргументы, которые мы хотим использовать для вызова, как показано в листинге 13-6.

```rust
use std::thread;
use std::time::Duration;

fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_closure(intensity));
        println!("Next, do {} situps!", expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_closure(intensity)
            );
        }
    }
}

fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
```

Теперь то, как выполнять дорогостоящие вычисления, определяется только в одном месте, и мы выполняем этот код только там, где нам нужны результаты.

Однако мы повторно представили одну из проблем из листинга 13-3: мы по-прежнему дважды вызываем замыкание в первом `if`блоке, что вызовет дорогостоящий код дважды и заставит пользователя ждать в два раза дольше, чем ему нужно. Мы могли бы решить эту проблему, создав локальную для этого `if`блока переменную для хранения результата вызова замыкания, но замыкания предоставляют нам другое решение. Мы немного поговорим об этом решении. Но сначала давайте поговорим о том, почему в определении замыкания нет аннотаций типов, и о свойствах, связанных с замыканиями.

## [Вывод типа замыкания и аннотация](https://doc.rust-lang.org/book/ch13-01-closures.html#closure-type-inference-and-annotation)

Замыкания не требуют, чтобы вы аннотировали типы параметров или возвращаемое значение, как `fn`это делают функции. Аннотации типов необходимы для функций, поскольку они являются частью явного интерфейса, доступного для ваших пользователей. Жесткое определение этого интерфейса важно для гарантии того, что все согласны с тем, какие типы значений использует и возвращает функция. Но замыкания не используются в открытом интерфейсе, подобном этому: они хранятся в переменных и используются без их именования и предоставления пользователям нашей библиотеки.

Замыкания обычно короткие и актуальны только в узком контексте, а не в произвольном сценарии. В этих ограниченных контекстах компилятор может надежно определить типы параметров и тип возвращаемого значения, подобно тому, как он может определить типы большинства переменных.

Заставлять программистов аннотировать типы в этих маленьких анонимных функциях было бы раздражающим и в значительной степени избыточным с информацией, уже доступной компилятору.

Как и в случае с переменными, мы можем добавить аннотации типов, если хотим повысить четкость и ясность за счет большей детализации, чем это необходимо. Аннотирование типов для замыкания, которое мы определили в листинге 13-5, будет выглядеть как определение, показанное в листинге 13-7.
```rust
 let expensive_closure = |num: u32| -> u32 {
	 println!("calculating slowly..."); 
	 thread::sleep(Duration::from_secs(2)); 
	 num 
};
```
С добавлением аннотаций типов синтаксис замыканий больше похож на синтаксис функций. Ниже приведено вертикальное сравнение синтаксиса определения функции, добавляющей 1 к своему параметру, и замыкания, имеющего такое же поведение. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это иллюстрирует, насколько синтаксис замыкания похож на синтаксис функции, за исключением использования конвейеров и количества необязательных синтаксиса:
```rust
fn add_one_v1 (x: u32) -> u32 { x + 1 } 
let add_one_v2 = |x: u32| -> u32 { x + 1 }; 
let add_one_v3 = |x| { x + 1 }; 
let add_one_v4 = |x| x + 1 ;
```
Определения закрытия будут иметь один конкретный тип, выведенный для каждого из их параметров и для их возвращаемого значения. Например, в листинге 13-8 показано определение короткого замыкания, которое просто возвращает значение, полученное в качестве параметра. Это замыкание не очень полезно, за исключением целей этого примера. Обратите внимание, что мы не добавили никаких аннотаций типов в определение: если мы затем попытаемся вызвать замыкание дважды, используя a `String`в качестве аргумента в первый раз и `u32`во второй раз, мы получим ошибку.

### *Не скомпилируется!*
```rust
let example_closure = |x| x;
let s = example_closure(String::from("hello")); 
let n = example_closure(5);
```
Когда мы в первый раз вызываем `example_closure` со значением типа `String`, компилятор выводит тип для  `x` и возвращаемого значения как `String`. Эти типы затем привязываются к замыканию в `example_closure` и мы получаем ошибку типа, если пытаемся использовать другой тип с тем же замыканием.

## [Сохранение замыканий используя обобщённые типы и типажи `Fn`](https://doc.rust-lang.ru/book/ch13-01-closures.html#%D0%A1%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B9-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-%D0%BE%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B8-%D1%82%D0%B8%D0%BF%D0%B0%D0%B6%D0%B8-fn)

Вернёмся к нашему приложению для создания тренировок. В листинге 13-6 наш код по-прежнему вызывал замыкание с дорогостоящим вычислением больше, чем это требовалось. Один из вариантов решения этой проблемы - сохранить результат дорогостоящего замыкания в переменной для повторного использования и использовать переменную в каждом месте, где нам нужен результат, вместо повторного вызова замыкания. Однако этот метод может привести к многократному повторению кода.

К счастью, нам доступно другое решение. Можно создать структуру, которая будет содержать замыкание и значение вызова замыкания. Структура будет выполнять замыкание только если нам понадобится результирующее значение, а результирующее значение будет кэшировать, поэтому остальной части нашего кода не понадобится отвечать за сохранение и повторное использование результата. Вы можете знать этот шаблон как _memoization (запоминание)_ или _lazy evaluation (ленивое вычисление)_.

Чтобы создать структуру, которая содержит замыкание, нам нужно указать тип замыкания, потому что определение структуры должно описывать типы каждого из его полей. Каждый экземпляр замыкания имеет свой уникальный анонимный тип: то есть, даже если два замыкания имеют одну и ту же сигнатуру, их типы по-прежнему считаются разными. Для определения структур, перечислений или параметров функций, которые используют замыкания, мы используем обобщённые типы и ограничения типажей, как мы обсуждали в Главе 10.

Типажи `Fn` входят в состав стандартной библиотеки. Все замыкания реализуют один из типажей: `Fn`, `FnMut` или `FnOnce`. Мы поговорим о различиях между ними в разделе ["Захват переменных окружения замыканиями"](https://doc.rust-lang.ru/book/ch13-01-closures.html#capturing-the-environment-with-closures); в данном примере мы можем использовать типаж `Fn`.

Мы добавляем типы в описание ограничений типажа `Fn` для описания типов параметров и возвращаемого значения, которое замыкания должны иметь для того, чтобы соответствовать данному ограничению типажа. В данном случае, наше замыкание имеет тип параметра `u32` и возвращает тип `u32`, поэтому сигнатуру ограничения типажа мы описываем как `Fn(u32) -> u32`.

Листинг 13-9 показывает определение структуры `Cacher` содержащей замыкание и необязательное значение результата:
```rust
struct Cacher<T> 
where 
T: Fn(u32) -> u32, 
{ 
	calculation: T, 
	value: Option<u32>, 
}
```
Структура `Cacher` имеет поле `calculation` обобщённого типа `T`. Ограничение типажа для `T`требует, чтобы обобщённый тип соответствовал замыканию: требование определяется типажом `Fn`. Любое замыкание, которые мы хотим сохранить в поле `calculation` должно иметь один параметр типа  `u32` (указанный внутри круглых скобок после `Fn`) и должно возвращать тип `u32` (указанный после `->`).
> Примечание. Функции также могут реализовывать все три типажа `Fn`. Если то, что мы хотим сделать, не требует захвата значения из среды, мы можем использовать функцию, а не замыкание, где нам нужно что-то, что реализует типаж `Fn`.
Поле `value`имеет тип `Option<u32>`. Прежде чем мы выполним закрытие, `value`будет `None`. Когда код, использующий a, `Cacher`запрашивает _результат_ закрытия, `Cacher`он выполнит закрытие в это время и сохранит результат в `Some`варианте в `value`поле. Затем, если код снова запрашивает результат закрытия, вместо повторного выполнения закрытия `Cacher`вернет результат, хранящийся в `Some`варианте.

Логика `value`поля, которое мы только что описали, определена в листинге 13.10.

Имя файла: src/main.rs
```rust
impl<T> Cacher<T> 
where 
T: Fn(u32) -> u32, 
{ 
	fn new(calculation: T) -> Cacher<T> 
	{ 
		Cacher 
		{ 
			calculation, 
			value: None, 
		} 
	} 
	fn value(&mut self, arg: u32) -> u32 { 
		match self.value { 
			Some(v) => v, 
			None => { 
				let v = (self.calculation)(arg); 
				self.value = Some(v); 
				v 
			} 
		}
	} 
}
```
Вместо непосредственного сохранения замыкания в переменной мы сохраняем новый экземпляр `Cacher`, который содержит замыкание. Затем в каждом месте, где мы хотим получить результат, мы вызываем метод `value` у экземпляра `Cacher`. Мы можем вызывать метод `value` столько раз, сколько захотим или не вызывать его вообще, а дорогостоящие вычисления будут выполняться максимум один раз.

Попробуйте запустить эту программу с помощью функции `main` из листинга 13-2. Измените значения в переменных `simulated_user_specified_value` и `simulated_random_number`, чтобы убедиться, что во всех случаях в различных блоках `if` и `else` текст `calculating slowly...`появляется только один раз и только при необходимости. `Cacher` заботится о логике, необходимой для обеспечения того, чтобы мы не вызывали дорогостоящие вычисления больше, чем нужно, чтобы мы могли сосредоточиться на бизнес-логике в `generate_workout`.

## [Ограничения реализации `Cacher`](https://doc.rust-lang.ru/book/ch13-01-closures.html#%D0%9E%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-cacher)

Кэширование значений - это обычно полезное поведение, которое мы могли бы использовать в других частях нашего кода с другими замыканиями. Однако в текущей реализации `Cacher` есть две проблемы, которые затрудняют его повторное использование в различных контекстах.

Первая проблема заключается в том, что экземпляр `Cacher` предполагает, что он всегда получит одно и то же значение параметра `arg` для метода `value`. То есть этот тест `Cacher` не пройдёт:
```rust
    #[test]
    fn call_with_different_values() {
        let mut c = Cacher::new(|a| a);

        let v1 = c.value(1);
        let v2 = c.value(2);

        assert_eq!(v2, 2);
    }
```
Этот тест создает новый `Cacher`экземпляр с замыканием, которое возвращает переданное ему значение. Мы вызываем `value`метод для этого `Cacher`экземпляра со `arg`значением 1, а затем со `arg`значением 2, и мы ожидаем, что вызов `value`со `arg`значением 2 вернет 2.

Запустите этот тест с `Cacher`реализацией в листинге 13-9 и листинге 13-10, и тест завершится ошибкой `assert_eq!`с этим сообщением:
```markdown
$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/cacher-074d7c200c000afa)

running 1 test
test tests::call_with_different_values ... FAILED

failures:

---- tests::call_with_different_values stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::call_with_different_values

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
Проблема в том, что при первом вызове `c.value`с 1 `Cacher` экземпляр, сохраненный `Some(1)`в `self.value`. После этого, независимо от того, что мы передаем в `value`метод, он всегда будет возвращать 1.

Попробуйте изменить `Cacher`, чтобы удерживать хеш-карту, а не одно значение. Ключи хэш-карты будут `arg`переданными значениями, а значения хэш-карты будут результатом вызова замыкания для этого ключа. Вместо того, чтобы смотреть, `self.value`имеет ли непосредственно значение `Some`или `None`, `value`функция будет искать `arg`в хеш-карте и возвращать значение, если оно присутствует. Если его нет, `Cacher`вызовет замыкание и сохранит полученное значение в хэш-карте, связанной с его `arg`значением.

Вторая проблема с текущей `Cacher`реализацией заключается в том, что она принимает только замыкания, которые принимают один параметр типа `u32`и возвращают `u32`. `usize`Например, мы можем захотеть кэшировать результаты замыканий, которые берут срез строки и возвращают значения. Чтобы решить эту проблему, попробуйте ввести более общие параметры, чтобы повысить гибкость `Cacher`функциональности.

## [Захват переменных окружения с помощью замыкания](https://doc.rust-lang.ru/book/ch13-01-closures.html#%D0%97%D0%B0%D1%85%D0%B2%D0%B0%D1%82-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F)

В примере генератора тренировок мы использовали только замыкания в качестве встроенных анонимных функций. Однако у замыканий есть дополнительная возможность, которой нет у функций: они могут захватывать своё окружение и получать доступ к переменным из области видимости, в которой они определены.

В листинге 13-12 приведён пример замыкания, хранящегося в переменной `equal_to_x`, в которой используется переменная `x` из ближайшего окружения замыкания.

Файл: src/main.rs

Имя файла: src/main.rs
```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```
Здесь, несмотря на то, что `x`это не один из параметров `equal_to_x`, `equal_to_x`замыкание может использовать `x`переменную, определенную в той же области, что `equal_to_x`и в . Мы не можем сделать то же самое с функциями;

В случае когда замыкание захватывает значение из своего окружения, оно использует дополнительную память для хранения значений используемых в теле замыкания. Такое использование памяти является накладными расходами, которые мы не хотим платить в общих случаях, там где мы хотим выполнить код, который не захватывает переменные окружения. Поскольку функциям никогда не разрешается захватывать их окружение, то определение и использование функций никогда не повлечёт за собой таких издержек.

Замыкания могут захватывать значения из своего окружения тремя способами, которые напрямую соответствуют трём способам, которыми функция может принимать параметр: забирать во владение, получать изменяемое заимствование и получать неизменяемое заимствование. Эти способы закодированы в трёх типажах `Fn` следующим образом:

-   замыкания типажа `FnOnce` потребляют переменные, которые они захватывают из окружающего контекста, известного как _окружение (environment)_ замыкания. Чтобы использовать захваченные переменные, замыкание должно стать владельцем этих переменных и переместить их в замыкание, когда оно определено. Часть имени `Once`отражает тот факт, что замыкание не может владеть одними и теми же переменными более одного раза, поэтому его можно вызывать только один раз.
-   замыкания типажа `FnMut` могут изменять значения переменных из окружения, поскольку они заимствуют изменяемые значения.
-   замыкания типажа `Fn` заимствуют значения из окружения без их изменения.

Когда вы создаёте замыкание Rust определяет какой типаж использовать, основываясь на том как замыкание использует значения из окружения. Все замыкания реализуют `FnOnce`, потому что все они могут быть вызваны хотя бы один раз. Замыкания, которые не перемещают захваченные переменные, также реализуют `FnMut`, а замыкания которым не требуется изменяемый доступ к захваченным переменным, также реализуют `Fn`. В листинге 13-12 замыкание `equal_to_x` заимствует `x` как неизменяемый (поэтому `equal_to_x` имеет типаж `Fn`), поскольку тело замыкания должно только читать значение в `x`.

Если вы хотите, чтобы замыкание стало владельцем значений, которые оно использует в окружении, то вы можете использовать ключевое слово `move` перед списком параметров. Этот метод в основном полезен при передаче замыкания в новый поток для перемещения данных, чтобы они принадлежали новому потоку.

> Примечание: замыкания с `move` могут по-прежнему реализовывать `Fn` или `FnMut`, даже если они захватывают переменные при перемещении. Это связано с тем, что типаж, реализуемый типом замыкания, определяется тем, что замыкание делает с захваченными значениями, а не тем, как оно их захватывает. Ключевое слово `move`указывает только как замыкание захватывает значения.