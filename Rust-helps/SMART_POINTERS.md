# [Умные указатели](https://doc.rust-lang.ru/book/ch15-00-smart-pointers.html#%D0%A3%D0%BC%D0%BD%D1%8B%D0%B5-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8)

_Указатель_ - это общая концепция для переменной, которая содержит адрес на участок памяти. Этот адрес "относится к", или "указывает на" некоторые другие данные. Наиболее общая разновидность указателя в Rust - это ссылка, о которой вы узнали из Главы 4. Ссылки обозначаются символом `&` и заимствуют значение на которое они указывают. Они не имеют каких-либо специальных возможностей, кроме как ссылаться на данные. Кроме того, они не имеют никаких накладных расходов и являются тем указателем, который мы используем чаще всего.

_Умные указатели_ с другой стороны, являются структурами данных, которые не только действуют как указатель, но также имеют дополнительные метаданные и дополнительные возможности. Концепция умных указателей не уникальна для Rust: умные указатели возникли в C ++ и существуют в других языках. В Rust есть разные умные указатели, определённые в стандартной библиотеке, которые обеспечивают функциональность выходящую за рамки ссылок. Одним из примеров, который мы рассмотрим в этой главе, является тип умного указателя _reference counting_ (подсчёт ссылок). Этот указатель позволяет иметь несколько владельцев данных с помощью отслеживания количества владельцев и очистки данных, когда владельцев не осталось.

В Rust, который использует концепцию владения и заимствования, дополнительная разница между ссылками и умными указателями заключается в том, что ссылки являются указателями, которые только заимствуют данные; против того, что во многих случаях умные указатели _владеют_ данными на которые они указывают.

Мы уже встречали несколько умных указателей в этой книге, таких как `String` и тип `Vec<T>` в главе 8, хотя мы не называли их умными указателями в тот момент. Оба этих типа считаются умными указателями, потому что они владеют некоторой областью памяти и позволяют ею манипулировать. У них также есть метаданные (например, их ёмкость) и дополнительные возможности или гарантии (например, `String` обеспечивает, что содержимое всегда будет действительными данными в кодировке UTF-8).

Умные указатели обычно реализуются с использованием структур. Характерной чертой, которая отличает умный указатель от обычной структуры является то, что для умных указателей реализованы типажи `Deref` и `Drop`. Типаж `Deref` позволяет экземпляру умной структуры указателя вести себя как ссылка, так что вы можете написать код работающий или со ссылками или с умными указателями. Типаж `Drop` позволяет настроить код запускаемый, когда экземпляр умного указателя выходит из области видимости. В этой главе мы обсудим оба типажа и продемонстрируем почему они важны для умных указателей.

Учитывая, что шаблон умный указатель является общим шаблоном проектирования часто используемым в Rust, эта глава не описывает все существующие умные указатели. Множество библиотек имеют свои умные указатели и вы также можете написать свои. Мы охватим наиболее распространённые умные указатели из стандартной библиотеки:

-   `Box<T>` для распределения значений в куче (памяти)
-   `Rc<T>` тип счётчика ссылок, который допускает множественное владение
-   Типы `Ref<T>` и `RefMut<T>`, доступ к которым осуществляется через тип `RefCell<T>`, который обеспечивает правила заимствования во время выполнения, вместо времени компиляции

# [Использование `Box<T>` для ссылки на данные в куче](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-boxt-%D0%B4%D0%BB%D1%8F-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8-%D0%BD%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B2-%D0%BA%D1%83%D1%87%D0%B5)

Наиболее простой умный указатель - это _box_, чей тип записывается как `Box<T>`. Такие переменные позволяют хранить данные в куче, а не в стеке. То, что остаётся в стеке, является указателем на данные в куче. Обратитесь к Главе 4, чтобы рассмотреть разницу между стеком и кучей.

У Box нет проблем с производительностью, кроме хранения данных в куче вместо стека. Но он также и не имеет множества дополнительных возможностей. Вы будете использовать его чаще всего в следующих ситуациях:

-   Если у вас есть тип, размер которого не может быть известен во время компиляции и вы хотите использовать значение этого типа в контексте, который требует точного размера
-   Когда у вас есть большой объем данных и вы хотите передать его во владение, но убедиться, что данные не будут скопированы, когда вы это сделаете
-   Когда вы хотите иметь значение и вам важно только то, что это тип, который реализует конкретный типаж, а не является конкретный типом

## [Использование `Box<T>` для хранения данных в куче](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-boxt-%D0%B4%D0%BB%D1%8F-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B2-%D0%BA%D1%83%D1%87%D0%B5)

Прежде чем мы обсудим этот вариант использования `Box<T>`, мы рассмотрим синтаксис и как взаимодействовать со значениями, хранящимися в `Box<T>`.

В листинге 15-1 показано, как использовать поле для хранения значения `i32` в куче:

Файл: src/main.rs
```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

Мы определяем переменную `b` как имеющую значение типа `Box`, указывающее на значение `5` в куче. Эта программа напечатает `b = 5`; в этом случае мы можем получить доступ к данным в поле, как если бы это были данные в стеке. Как и любое значение во владении, данная память будет освобождена, когда box выйдет из области действия, что происходит с `b`в конце `main`. Освобождается память, занимаемая box (хранится в стеке), и тех данных, на которые он указывает (хранятся в куче).

Размещение единственного значения в куче не очень полезно, поэтому вы не будете часто использовать box сам по себе таким способом. Иметь единственное значение `i32` в стеке, где они хранятся по умолчанию, подходит в большинстве ситуаций. Давайте рассмотрим случай, когда Box позволяет определять типы, которые были бы невозможны, если бы у нас не было Box.

 ## [Включение рекурсивных типов с помощью Boxes](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-boxes)

Во время компиляции Rust должен знать, сколько места занимает тип. Некоторый тип, чей размер не может быть известен во время компиляции, является _рекурсивным типом_ (recursive type), где значение может иметь в своём составе другое значение того же типа. По причине того, что это вложение значений может теоретически продолжаться бесконечно, Rust не знает, сколько пространства памяти необходимо для значений рекурсивного типа. Однако Box имеет известный размер, поэтому используя Box в определении рекурсивного типа, можно его реализовать.

Давайте рассмотрим _cons список_ (cons - функция конструктор, создаёт объекты памяти, которые содержат два значения или указатели на значения), который является распространённым в функциональных языках программирования типом данных, как пример рекурсивного типа. Тип "cons список", который мы определим, является простым, за исключением рекурсии; поэтому концепции, используемые в примере, с которым мы будем работать, будут полезны и в более сложных ситуациях, связанных с рекурсивными типами.

#### [Больше информации о cons списке](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%91%D0%BE%D0%BB%D1%8C%D1%88%D0%B5-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8-%D0%BE-cons-%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B5)

_cons список_ (cons list) - это структура данных, которая пришла из языка программирования Lisp и его диалектов. В Lisp, функция `cons` (сокращение от "construct function" функция-конструктор) создаёт новую пару используя два аргумента, один из которых значение, а другой - пара. Эти пары, содержащие другие пары, образуют список.

Концепция функции конструктора прошла свой путь и превратилась в более общий функциональный, программный жаргон: "to cons _х_ onto _у_" неформально означает создание нового экземпляра контейнера, помещая элемент _х_ в начале нового контейнера, за которым следует контейнер _y_.

Каждый элемент в cons списке содержит два элемента: значение текущего элемента и следующий элемент. Последний элемент в списке содержит только значение называемое `Nil`без следующего элемента. Cons список создаётся путём рекурсивного вызова функции `cons`. Каноничное имя для обозначения базового случая рекурсии - `Nil`. Обратите внимание, что это не то же самое, что понятие “null” или “nil” из главы 6, которая является недействительным или отсутствующим значением.

Хотя функциональные языки программирования часто используют cons списки, этот список не является широко используемой структурой данных в Rust. Большую часть времени, когда есть список элементов в Rust, лучше использовать `Vec<T>`. Более сложные рекурсивные типы данных _являются_ полезными в различных ситуациях, но начиная изучение с cons списка, мы можем исследовать, как box-ы позволяют определить рекурсивный тип данных без особых проблем.

Листинг 15-2 содержит объявление перечисления cons списка. Обратите внимание, что этот код не будет компилироваться, потому что тип `List` не имеет известного размера, что мы и продемонстрируем.

```rust 
enum List {
    Cons(i32, List),
    Nil,
}
```

> Примечание: мы реализуем cons список, который для примера содержит только значения `i32`. Чтобы определить тип cons список для хранения значений любого типа, мы могли бы использовать обобщённые типы, как обсуждалось в главе 10.

Использование типа `List` для хранения списка `1, 2, 3` будет выглядеть как код в листинге 15-3:

```rust 
enum List {
    Cons(i32, List),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

Первое значение `Cons` содержит `1` и другой `List`. Это значение `List` является следующим значением `Cons`, которое содержит `2` и другой `List`. Это значение `List` является ещё один значением `Cons`, которое содержит `3` и значение `List`, которое наконец является `Nil`, не рекурсивным вариантом, сигнализирующим об окончании списка.

Если мы попытаемся скомпилировать код в листинге 15-3, мы получим ошибку, показанную в листинге 15-4:
```markdown
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +

error[E0391]: cycle detected when computing drop-check constraints for `List`
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing drop-check constraints for `List` again
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, value: List } }`

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to 2 previous errors
```
Листинг 15-3: Ошибка, получаемая при попытке определить бесконечное рекурсивное перечисление

Ошибка сообщает, что этот тип "имеет бесконечный размер". Причина в том, что мы определили `List` с рекурсивным вариантом: он содержит другое значение самого себя. В результате Rust не может понять, сколько места ему нужно для хранения значения `List`. Давайте разберёмся, почему мы получаем эту ошибку. Во-первых, давайте посмотрим как Rust решает, сколько места ему нужно для хранения значения нерекурсивного типа.

## [Вычисление размера нерекурсивного типа](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D0%B0-%D0%BD%D0%B5%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0)

Вспомните перечисление `Message` определённое в листинге 6-2, когда обсуждали объявление enum в главе 6:
```rust 
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
Чтобы определить, сколько памяти выделять под значение `Message`, Rust проходит каждый из вариантов, чтобы увидеть, какой вариант требует наибольшее количество памяти. Rust видит, что для `Message::Quit` не требуется места, `Message::Move` хватает места для хранения двух значений `i32` и т.д. Так как будет использоваться только один вариант, то наибольшее пространство, которое потребуется для значения `Message`, это пространство, которое потребуется для хранения самого большого из вариантов перечисления.

Сравните это с тем, что происходит, когда Rust пытается определить, сколько места необходимо рекурсивному типу, такому как перечисление `List` в листинге 15-2. Компилятор смотрит на вариант `Cons`, который содержит значение типа `i32` и значение типа `List`. Следовательно, `Cons` нужно пространство, равное размеру `i32` плюс размер `List`. Чтобы выяснить, сколько памяти необходимо типу `List`, компилятор смотрит на варианты, начиная с `Cons`. Вариант `Cons` содержит значение типа `i32` и значение типа `List`, и этот процесс продолжается бесконечно, как показано на рисунке 15-1.

![slice-link](https://raw.githubusercontent.com/Abuzik/reborn-block/0902656ed67519e912e28df46a30ffd928a6d3c1/Rust-helps/images/8.svg "Slice")

## [Использование `Box<T>` для получения рекурсивного типа с известным размером](https://doc.rust-lang.ru/book/ch15-01-box.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-boxt-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0-%D1%81-%D0%B8%D0%B7%D0%B2%D0%B5%D1%81%D1%82%D0%BD%D1%8B%D0%BC-%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D0%BE%D0%BC)

Rust не может понять, сколько места выделить для типов определённых рекурсивно, поэтому компилятор выдаёт ошибку в листинге 15-4. Но ошибка включает в себя это полезное предложение:
```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```
Листинг 15-5: Определение `List`, которое использует `Box`, чтобы иметь известный размер

Варианту `Cons` понадобится размер `i32` плюс место для хранения данных указателя Box. Вариант `Nil` не хранит значений, поэтому ему нужно меньше места, чем варианту `Cons`. Теперь мы знаем, что любое значение `List` будет занимать размер `i32` плюс размер данных указателя Box. Используя Box, мы сломали бесконечную рекурсивную цепочку, так что компилятор может определить размер, необходимый для хранения значения `List`. На рисунке 15-2 показано как теперь выглядит вариант `Cons`.

![slice-link](https://raw.githubusercontent.com/Abuzik/reborn-block/0902656ed67519e912e28df46a30ffd928a6d3c1/Rust-helps/images/9.svg "Slice")

Рисунок 15-2: `List`, размер которого не безграничен, потому что `Cons` содержит `Box`

Box-ы обеспечивают только косвенность и выделение в куче; у них нет других специальных возможностей, таких как те, которые мы увидим у других типов умных указателей. Они также не имеют накладных расходов из-за этих специальных возможностей, поэтому могут быть полезны в случаях, похожих на cons список, где косвенность - единственная нужная функциональность. Мы рассмотрим ещё больше вариантов использования типа `Box` в главе 17.

Тип `Box<T>` является умным указателем, потому что он реализует типаж `Deref`, что позволяет значениям `Box<T>` обрабатываться как ссылки. Когда значение `Box<T>` выходит из области видимости, то данные кучи, на которые указывает Box, очищаются благодаря реализации типажа `Drop`. Давайте рассмотрим эти два типажа более подробно. Эти два типажа будут ещё более важными для функциональности, предоставляемой другими типами умных указателей, которые мы обсудим в оставшихся частях этой главы.

## [Обращение с умными указателями как с обычными ссылками с помощью `Deref` типажа](https://doc.rust-lang.ru/book/ch15-02-deref.html#%D0%9E%D0%B1%D1%80%D0%B0%D1%89%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81-%D1%83%D0%BC%D0%BD%D1%8B%D0%BC%D0%B8-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8F%D0%BC%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%81-%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%BC%D0%B8-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0%D0%BC%D0%B8-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-deref-%D1%82%D0%B8%D0%BF%D0%B0%D0%B6%D0%B0)

Реализация типажа `Deref` позволяет настроить поведение _оператора разыменования_(dereference operator), `*` (отличается от умножения или оператора глобального подключения). Реализуя типаж `Deref` таким образом, что умный указатель может использоваться как обычная ссылка, вы можете писать код, который работает с ссылками и использовать этот код также с умными указателями.

Давайте сначала посмотрим, как работает оператор разыменования с обычными ссылками. Затем мы попытаемся определить пользовательский тип, который ведёт себя как `Box<T>` и посмотрим, почему оператор разыменования не работает как ссылка для нового объявленного типа. Мы рассмотрим, как реализация типажа `Deref` делает возможным работу умных указателей аналогично ссылкам. Затем посмотрим на _разыменованное приведение_(deref coercion) в Rust и как оно позволяет работать с любыми ссылками или умными указателями.

 > Примечание: есть одна большая разница между типом `MyBox<T>`, который мы собираемся создать и реальным `Box<T>`: наша версия не будет хранить свои данные в куче. В примере мы сосредоточимся на типаже `Deref`, поэтому менее важно то, где данные хранятся, чем поведение подобное указателю.

### [Следование по указателю к значению с помощью оператора разыменования](https://doc.rust-lang.ru/book/ch15-02-deref.html#%D0%A1%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8E-%D0%BA-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8E-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0-%D1%80%D0%B0%D0%B7%D1%8B%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

Обычная ссылка является типом указателя и один из способов думать про указатель, как будто это стрела в направлении к значению, хранящемуся где-то ещё. В листинге 15-6 мы создаём ссылку на значение `i32` и затем используем оператор разыменования, чтобы следовать по ссылке к данным:

Файл: src/main.rs
```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
Листинг 15-6: Использование оператора разыменования для следования по ссылке к значению `i32`

Переменная `x` содержит тип `i32` со значением `5`. Мы устанавливаем `y` равным ссылке на `x`. Мы можем утверждать, что `x` равно `5`. Тем не менее, если мы хотим сделать утверждение о значении `y` то, мы должны использовать оператор `*y`, чтобы проследовать по ссылке к значению, на которое она указывает (следовательно, _разыменовывает_ (dereference)). Как только мы разыменовываем `y`, у нас есть доступ к целочисленному значению `y`, на которое указывает ссылка и мы можем сравнить его с `5`.

Если бы мы попытались написать `assert_eq!(5, y);`, то получили ошибку компиляции:
```
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` due to previous error
```
Сравнение числа и ссылки на число не допускается, потому что они различных типов. Мы должны использовать оператор разыменования, чтобы перейти по ссылке на значение, на которое она указывает.

### [Использование `Box<T>` как ссылку](https://doc.rust-lang.ru/book/ch15-02-deref.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-boxt-%D0%BA%D0%B0%D0%BA-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D1%83)

Можно переписать код в листинге 15-6, чтобы использовать `Box<T>` вместо ссылки; оператор разыменования будет работать, как показано в листинге 15-7:

Файл: src/main.rs
```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
Листинг 15-7: Использование оператора разыменования с типом `Box<i32>`

Разница между листингом 15-7 и листингом 15-6 состоит в том, что здесь мы устанавливаем `y`на экземпляр box, указывающий на значение `x`, а не ссылкой, указывающей на значение `x` . В последнем утверждении мы можем использовать оператор разыменования, чтобы проследовать за указателем box-а так же, как мы это делали когда `y` была ссылкой. Далее мы рассмотрим, что особенного у типа `Box<T>`, что позволяет нам использовать оператор разыменования, определяя наш собственный тип `Box`.

### [Определение собственного умного указателя](https://doc.rust-lang.ru/book/ch15-02-deref.html#%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D1%83%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)

Давайте создадим умный указатель, похожий на тип `Box<T>` предоставляемый стандартной библиотекой, чтобы понять как поведение умных указателей отличается от поведения обычной ссылки. Затем мы рассмотрим вопрос, как добавить возможность использовать оператор разыменования.

Тип `Box<T>` в конечном итоге определяется как структура кортежа с одним элементом, поэтому в листинге 15-8 аналогичным образом определяется `MyBox<T>`. Мы также определим функцию `new`, чтобы она соответствовала функции `new`, определённой в `Box<T>`.

Файл: src/main.rs
```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

fn main() {}
```
Листинг 15-8: Определение типа `MyBox<T>`

Мы определяем структуру с именем `MyBox` и объявляем обобщённый параметр `T`, потому что мы хотим, чтобы наш тип хранил значения любого типа. Тип `MyBox` является структурой кортежа с одним элементом типа `T`. Функция `MyBox::new` принимает один параметр типа `T` и возвращает экземпляр `MyBox`, который содержит переданное значение.

Давайте попробуем добавить функцию `main` из листинга 15-7 в листинг 15-8 и изменим её на использование типа `MyBox<T>`, который мы определили вместо `Box<T>`. Код в листинге 15-9 не будет компилироваться, потому что Rust не знает, как разыменовывать `MyBox`.
```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
Листинг 15-9. Попытка использовать `MyBox<T>` таким же образом, как мы использовали ссылки и `Box<T>`

Вот результат ошибки компиляции:
```
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` due to previous error
```
Наш тип `MyBox<T>` не может быть разыменован, потому что мы не реализовали эту возможность. Чтобы включить разыменование с помощью оператора `*`, мы реализуем типаж `Deref`.

### [Трактование типа как ссылки реализуя типаж `Deref`](https://doc.rust-lang.ru/book/ch15-02-deref.html#%D0%A2%D1%80%D0%B0%D0%BA%D1%82%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-%D0%BA%D0%B0%D0%BA-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D1%83%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0%D0%B6-deref)

Как обсуждалось в разделе [“Реализация трейта для типа”](https://doc.rust-lang.ru/book/ch10-02-traits.html#implementing-a-trait-on-a-type) Главы 10, для реализации типажа нужно предоставить реализации требуемых методов типажа. Типаж `Deref`, предоставляемый стандартной библиотекой требует от нас реализации одного метода с именем `deref`, который заимствует `self` и возвращает ссылку на внутренние данные. Листинг 15-10 содержит реализацию `Deref` добавленную к определению `MyBox`:

Файл: src/main.rs
```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```
Синтаксис `type Target = T;` определяет связанный тип для использования у типажа `Deref`. Связанные типы - это немного другой способ объявления обобщённого параметра, но пока вам не нужно о них беспокоиться; мы рассмотрим их более подробно в главе 19.

Мы заполняем тело метода `deref` с помощью `&self.0`, поэтому `deref` возвращает ссылку на значение, к которому мы хотим получить доступ с помощью оператора `*`. Вспомним из раздела [”Использование структур кортежей без именованных полей для создания разных типов”](https://doc.rust-lang.ru/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types) . главы 5, что `.0` обращается к первому значению в структуре кортежа. Функция `main`в листинге 15-9, которая вызывает `*` для `MyBox<T>`, теперь компилируется и все утверждения проходят!

Без типажа `Deref` компилятор может только разыменовывать `&` ссылки. Метод `deref` даёт компилятору возможность принимать значение любого типа, реализующего `Deref` и вызывать метод `deref` чтобы получить ссылку `&`, которую он знает, как разыменовывать.

Когда мы ввели `*y` в листинге 15-9, Rust фактически выполнил за кулисами такой код:
```
*(y.deref())
```
### [Неявные разыменованные приведения с функциями и методами](https://doc.rust-lang.ru/book/ch15-02-deref.html#%D0%9D%D0%B5%D1%8F%D0%B2%D0%BD%D1%8B%D0%B5-%D1%80%D0%B0%D0%B7%D1%8B%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D0%BC%D0%B8-%D0%B8-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D0%BC%D0%B8)

_Разыменованное приведение_ (Deref coercion) - это удобство, которое Rust выполняет над аргументами функций и методов. Разыменованное приведение преобразует ссылку на исходный тип, реализующий типаж `Deref`, в ссылку на целевой тип, в который `Deref` может преобразовать исходный тип. Разыменованное приведение происходит автоматически, когда мы передаём ссылку на значение определённого типа в качестве аргумента функции или метода, который не соответствует типу параметра в определении функции или метода. Последовательность вызовов метода `deref` преобразует предоставленный исходный тип, в целевой тип необходимый параметру.

Разыменованное приведение было добавлено в Rust, так что программистам, пишущим вызовы функций и методов, не нужно добавлять множество явных ссылок и разыменований с помощью использования `&` и `*`. Функциональность разыменованного приведения также позволяет писать больше кода, который может работать как с ссылками, так и с умными указателями.

Чтобы увидеть разыменованное приведение в действии, давайте воспользуемся типом `MyBox<T>` определённым в листинге 15-8, а также реализацию `Deref` добавленную в листинге 15-10. Листинг 15-11 показывает определение функции, у которой есть параметр типа срез строки:

Файл: src/main.rs
```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}
```
Листинг 15-11: Функция `hello` имеющая параметр  `name` типа `&str`

Можно вызвать функцию `hello` со срезом строки в качестве аргумента, например `hello("Rust");`. Разыменованное приведение делает возможным вызов `hello` со ссылкой на значение типа `MyBox<String>`, как показано в листинге 15-12.
```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```
Листинг 15-12: Вызов `hello` со ссылкой на значение `MyBox<String>`, которое работает из-за разыменованного приведения

Здесь мы вызываем функцию `hello` с аргументом `&m`, который является ссылкой на значение `MyBox<String>`. Поскольку мы реализовали типаж `Deref` для `MyBox<T>` в листинге 15-10, то Rust может преобразовать `&MyBox<String>` в `&String` вызывая `deref`. Стандартная библиотека предоставляет реализацию типажа `Deref` для типа `String`, которая возвращает срез строки, это описано в документации API типажа `Deref`. Rust снова вызывает `deref`, чтобы превратить `&String` в `&str`, что соответствует определению функции `hello`.

Если бы Rust не реализовал разыменованное приведение, мы должны были бы написать код в листинге 15-13 вместо кода в листинге 15-12 для вызова метода `hello` со значением типа `&MyBox<String>`.

Файл: src/main.rs
```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```
Код `(*m)` разыменовывает `MyBox<String>` в `String`. Затем `&` и `[..]` принимают строковый срез `String`, равный всей строке, чтобы соответствовать сигнатуре `hello`. Код без разыменованного приведения сложнее читать, писать и понимать со всеми этими символами. Разыменованное приведение позволяет Rust обрабатывать эти преобразования для нас автоматически.

Когда типаж `Deref` определён для задействованных типов, Rust проанализирует типы и будет использовать `Deref::deref` столько раз, сколько необходимо, чтобы получить ссылку, соответствующую типу параметра. Количество раз, которое нужно вставить `Deref::deref`определяется во время компиляции, поэтому использование разыменованного приведения не имеет накладных расходов во время выполнения!

### [Как разыменованное приведение взаимодействует с изменяемостью](https://doc.rust-lang.ru/book/ch15-02-deref.html#%D0%9A%D0%B0%D0%BA-%D1%80%D0%B0%D0%B7%D1%8B%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D1%83%D0%B5%D1%82-%D1%81-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C%D1%8E)

Подобно тому, как вы используете типаж `Deref` для переопределения оператора `*` у неизменяемых ссылок, вы можете использовать типаж `DerefMut` для переопределения оператора `*` у изменяемых ссылок.

Rust выполняет разыменованное приведение, когда находит типы и реализации типажей в трёх случаях:

-   Из типа `&T` в тип `&U` когда верно `T: Deref<Target=U>`
-   Из типа `&mut T` в тип `&mut U` когда верно `T: DerefMut<Target=U>`
-   Из типа `&mut T` в тип `&U` когда верно `T: Deref<Target=U>`

Первые два случая одинаковы за исключением изменяемости. В первом случае говорится, что если у вас есть тип `&T`, а `T` реализует типаж `Deref` для некоторого типа `U`, вы можете прозрачно получить `&U`. Во втором случае утверждается, что такое же разыменованное приведение происходит для изменяемых ссылок.

Третий случай хитрее: Rust также приводит изменяемую ссылку к неизменяемой. Но обратное _не_ представляется возможным: неизменяемые ссылки никогда не приводятся к изменяемым ссылкам. Из-за правил заимствования, если у вас есть изменяемая ссылка, эта изменяемая ссылка должна быть единственной ссылкой на данные (в противном случае программа не будет компилироваться). Преобразование одной изменяемой ссылки в неизменяемую ссылку никогда не нарушит правила заимствования. Преобразование неизменяемой ссылки в изменяемую ссылку потребует наличия только одной неизменяемой ссылки на эти данные, и правила заимствования не гарантируют этого. Следовательно, Rust не может сделать предположение, что преобразование неизменяемой ссылки в изменяемую ссылку возможно.

## [Запуск кода при очистке с помощью типажа `Drop`](https://doc.rust-lang.ru/book/ch15-03-drop.html#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%BF%D1%80%D0%B8-%D0%BE%D1%87%D0%B8%D1%81%D1%82%D0%BA%D0%B5-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D1%82%D0%B8%D0%BF%D0%B0%D0%B6%D0%B0-drop)

Второй типаж, важный для шаблона умного указателя, - это `Drop`, который позволяет настроить то, что происходит, когда значение собирается выйти из области видимости. Вы можете предоставить реализацию `Drop` для любого типа, а указанный код можно использовать для освобождения ресурсов, таких как файлы или сетевые подключения. Мы представим `Drop` в контексте умных указателей, потому что функциональность типажа `Drop`почти всегда используется при их реализации. Например, `Box<T>` настраивает `Drop` для освобождения пространства в куче, на которое указывает Box.

В некоторых языках программист должен вызывать код для освобождения памяти или ресурсов каждый раз, когда они заканчивают использовать экземпляр умного указателя. Если программист забудет это сделать, то система может стать перегруженной и начать зависать. В Rust можно указать, что определённый код будет запускаться всякий раз, когда значение выходит из области видимости и компилятор вставит такой код автоматически. В результате вам не нужно заботиться о размещении кода очистки ресурсов во всей программе, где экземпляр определённого типа заканчивает существование - вы не потеряете системные ресурсы!

Укажите код, который будет запускаться, когда значение выходит из области видимости с помощью реализации типажа `Drop`. Типаж `Drop` требует, чтобы вы реализовали один метод с именем `drop`, который принимает изменяемую ссылку на `self`. Чтобы увидеть, когда Rust вызывает метод `drop`, давайте реализуем `drop` с помощью оператора `println!`.

В листинге 15-14 показана структура `CustomSmartPointer`, единственная функция которой заключается в том, что она будет печатать `Dropping CustomSmartPointer!` когда экземпляр выходит за область видимости. Этот пример демонстрирует, когда Rust выполняет функцию `drop` .

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
```
Листинг 15-14: Структура `CustomSmartPointer`, которая реализует типаж `Drop`, где мы поместили бы код очистки

Типаж `Drop` входит в прелюдию, поэтому не нужно подключать его в область видимости. Мы реализуем типаж `Drop` у структуры `CustomSmartPointer` и предоставляем реализацию для метода `drop`, который вызывает `println!`. В теле функции `drop` можно разместить любую логику, которую хочется запустить, когда экземпляр вашего типа выходит из области видимости. Здесь мы печатаем некоторый текст, чтобы продемонстрировать, когда Rust вызовет `drop`.

В `main` мы создаём два экземпляра `CustomSmartPointer` и затем печатаем `CustomSmartPointers created` . В конце `main` наши экземпляры `CustomSmartPointer` выйдут из области видимости и Rust вызовет код, который мы добавили в метод `drop`, который и напечатает наше окончательное сообщение. Обратите внимание, что нам не нужно вызывать метод `drop` явно.

Когда мы запустим эту программу, мы увидим следующий вывод:
```
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
```
Это сообщение об ошибке говорит, что мы не можем явно вызывать `drop`. В сообщении об ошибке используется термин _деструктор (destructor)_, который является общим термином программирования для функции, которая очищает экземпляр. _Деструктор_ аналогичен _конструктору_, который создаёт экземпляр. Функция `drop` в Rust является определённым деструктором.

Rust не позволяет явно вызывать `drop`, потому что Rust всё равно будет автоматически вызывать `drop` для значения в конце `main`. Это приведёт к ошибке _двойного освобождения_, потому что Rust будет пытаться очистить одно и то же значение дважды.

Мы не можем отключить автоматическую вставку `drop` кода, когда значение выходит из области видимости и мы не можем явно вызвать метод `drop`. Таким образом, если нам нужно принудительно очистить значение, мы можем использовать функцию `std::mem::drop`.

Функция `std::mem::drop` отличается от метода `drop` типажа `Drop`. Мы вызываем её, передавая значение, которое мы хотим принудительно освободить в качестве аргумента. Функция находится в прелюдии, поэтому можно изменить `main` из листинга 15-15 так, чтобы вызвать функцию `drop`, как показано в листинге 15-16:

Файл: src/main.rs
```rust
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}

```
Листинг 15-16: Вызов `std::mem::drop` для явного удаления значения до его выхода из области видимости

Выполнение данного кода выведет следующий результат:
```
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
```
Текст `Dropping CustomSmartPointer with data` some data`!`, напечатанный между `CustomSmartPointer created.` и текстом `CustomSmartPointer dropped before the end of main.`, показывает, что код метода `drop` вызывается для удаления `c` в этой точке.

Вы можете использовать код, указанный в реализации типажа `Drop`, чтобы сделать очистку удобной и безопасной: например, вы можете использовать её для создания своего собственного менеджера памяти! С помощью типажа `Drop` и системы владения Rust не нужно специально заботиться о том, чтобы освобождать ресурсы, потому что Rust делает это автоматически.

Также не нужно беспокоиться о проблемах, возникающих в результате случайной очистки значений, которые всё ещё используются: система владения, которая гарантирует, что ссылки всегда действительны, также гарантирует, что `drop` вызывается только один раз, когда значение больше не используется.

После того, как мы познакомились с `Box<T>` и характеристиками умных указателей, познакомимся с её другими умными указателями, определёнными в стандартной библиотеке.