## Настройка сборок с профилями релизов

В Rust профили выпуска - это предопределённые и настраиваемые профили с различными конфигурациями, которые позволяют программисту лучше контролировать различные параметры компиляции кода. Каждый профиль настраивается независимо от других.

Cargo имеет два основных профиля: профиль dev используемый Cargo при запуске cargo build и профиль release используемый Cargo при запуске cargo build --release. Профиль dev определён со значениями по умолчанию для разработки, а профиль release имеет значения по умолчанию для релиз сборок.

Эти имена профилей могут быть знакомы по результатам ваших сборок:
```
$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
```
Выводы для dev и release, показанные при сборке указывают, что компилятор использует разные профили.

Cargo имеет настройки по умолчанию для каждого из профилей, которые применяются, когда в файле проекта Cargo.toml нет разделов [profile.*]. Добавляя разделы [profile.*] для любого профиля, который вы хотите настроить, вы можете переопределить любое подмножество настроек по умолчанию. Например, вот значения по умолчанию для параметра opt-level для профилейdev и release:
```

[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```
Параметр opt-level управляет количеством оптимизаций, которые Rust будет применять к вашему коду, в диапазоне от 0 до 3. Применение дополнительных оптимизаций увеличивает время компиляции, поэтому, если вы находитесь в разработке и часто компилируете свой код, вам понадобится быстрая компиляция, даже если полученный код работает медленнее. Вот почему по умолчанию opt-level для dev равно значению 0. Когда вы будете готовы выпустить свой код, лучше потратить больше времени на компиляцию. Вы будете компилировать в режиме релиза только один раз, но вы будете запускать скомпилированную программу много раз, поэтому режим релиза тратит больше времени на компиляцию кода, который работает быстрее. Вот почему по умолчанию opt-level для профиля release является значением 3.
Полный список параметров конфигурации и значений по умолчанию для каждого профиля вы можете найти в документации Cargo.

## Создание полезных комментариев к документации

Аккуратное документирование ваших пакетов поможет другим пользователям знать, как и когда их использовать, поэтому стоит потратить время на написание документации. В главе 3 мы обсуждали, как комментировать код Rust, используя две косые черты, //. В Rust также есть особый вид комментариев к документации, который обычно называется комментарием к документации, который генерирует документацию HTML. HTML-код отображает содержимое комментариев к документации для публичных элементов API, предназначенных для программистов, заинтересованных в знании того, как использовать вашу библиотеку, в отличие от того, как она реализована.

Комментарии к документации используют три слеша, /// вместо двух и поддерживают нотацию Markdown для форматирования текста. Размещайте комментарии к документации непосредственно перед элементом, который они документируют. В листинге 14-1 показаны комментарии к документации для функции add_one в библиотеке с именем my_crate:
```rust

/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

Здесь мы даём описание того, что делает функция add_one, начинаем раздел с заголовка Examples, а затем предоставляем код, который демонстрирует, как использовать функцию add_one. Мы можем сгенерировать документацию HTML из этого комментария к документации, запустив cargo doc. Эта команда запускает инструмент rustdoc, поставляемый с Rust, и помещает сгенерированную HTML-документацию в каталог target/doc.

Для удобства, запустив cargo doc --open, мы создадим HTML для документации вашей текущей библиотеки (а также документацию для всех зависимостей вашей библиотеки) и откроем результат в веб-браузере.


## Часто используемые разделы

Мы использовали Markdown заголовок # Examples в листинге 14-1 для создания раздела в HTML с заголовком "Examples". Вот некоторые другие разделы, которые авторы библиотек обычно используют в своей документации:

- Panics: Сценарии, в которых документированная функция может вызывать панику. Вызывающие функцию, которые не хотят, чтобы их программы паниковали, должны убедиться, что они не вызывают функцию в этих ситуациях.
- Ошибки: Если функция возвращает Result, описание типов ошибок, которые могут произойти и какие условия могут привести к тому, что эти ошибки могут быть возвращены, может быть полезным для вызывающих, так что они могут написать код для обработки различных типов ошибок разными способами.
- Безопасность: Если функция является unsafe для вызова (мы обсуждаем безопасность в главе 19), должен быть раздел, объясняющий, почему функция небезопасна и охватывающий инварианты, которые функция ожидает от вызывающих сторон.

## Комментирование содержащихся элементов

Другой стиль комментариев к документу, //!, добавляет документацию к элементу, содержащему комментарии, а не добавляет документацию к элементам, следующим за комментариями. Обычно мы используем эти комментарии к документу внутри корневого файла крейта (src/lib.rs по соглашению) или внутри модуля для документирования крейта или модуля в целом. Например, если мы хотим добавить документацию, описывающую назначение крейта my_crate, который содержит функцию add_one, мы можем добавить комментарии к документации, начинающиеся с //!, в начало src/lib.rs, как показано в листинге 14-2:
```rust
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```
Обратите внимание, что нет кода после последней строки, начинающейся с //!. Поскольку мы начинали комментарии с //! вместо ///, мы документируем элемент, который содержит этот комментарий, а не элемент, следующий за этим комментарием. В этом случае элементом, содержащим этот комментарий, является файл src/lib.rs, который является корнем крейта. Эти комментарии описывают всю крейт.

Когда мы запускаем cargo doc --open, эти комментарии будут отображаться на первой странице документации для my_crate над списком публичных элементов в библиотеке.

Обратите внимание, что типы PrimaryColor и SecondaryColor не указаны на главной странице, равно как и функция mix. Мы должны нажать kinds и utils, чтобы увидеть их.

В другой библиотеке, которая зависит от этой библиотеки, потребуются операторы use, которые подключают элементы из art в область видимости, определяя структуру модуля, которая определена в данный момент. В листинге 14-4 показан пример крейта, в котором используются элементы PrimaryColor и mix из крейта art:
```rust
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
```

Автор кода в листинге 14-4, в котором используется крейт art, должен был выяснить, что PrimaryColor находится в модуле kinds, а mix находится в модуле utils. Модульная структура крейта art больше уместна разработчикам работающим над крейтом art, чем разработчикам, использующим крейт art. Внутренняя структура, которая организует части библиотеки в модуль kinds и модуль utils, не содержит никакой полезной информации для того, кто пытается понять, как использовать крейт art. Вместо этого, структура модулей крейта art вызывает путаницу, потому что разработчики должны выяснить где делать поиск и структура неудобна, потому что разработчики должны указывать имена модулей в операторах use.

Чтобы удалить внутреннюю организацию из общедоступного API, мы можем изменить код крейта art в листинге 14-3, чтобы добавить операторы pub use для повторного реэкспорта элементов на верхнем уровне, как показано в листинге 14-5:
```rust

//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    // --snip--
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        SecondaryColor::Orange
    }
}

```

## [Добавление второго крейта в рабочее пространство](https://doc.rust-lang.ru/book/ch14-03-cargo-workspaces.html#%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D1%82%D0%BE%D1%80%D0%BE%D0%B3%D0%BE-%D0%BA%D1%80%D0%B5%D0%B9%D1%82%D0%B0-%D0%B2-%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B5%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%BE)

Далее давайте создадим ещё одного участника пакета в рабочей области и назовём его `add_one`. Внесите изменения в _Cargo.toml_ верхнего уровня так, чтобы указать путь _add_one_ в списке `members`:
```
[workspace]

members = [
    "adder",
    "add_one",
]
```
Затем сгенерируйте новый крейт библиотеки с именем `add_one`:
```
$ cargo new add_one --lib
     Created library `add_one` package
```
Ваш каталог _add_ должен теперь иметь следующие каталоги и файлы:
```
├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
```

Теперь, когда у нас есть крейт библиотеки в рабочей области, мы можем получить исполняемый крейт `adder` зависящий от библиотечного крейта `add-one`. Сначала нам нужно добавить путь зависимости от `add-one` в _adder/Cargo.toml_.

Файл: adder/Cargo.toml
```
[dependencies]
add_one = { path = "../add_one" }
```

Cargo не предполагает, что крейты в рабочей области будут зависеть друг от друга, поэтому нам нужно чётко указать отношения зависимостей между крейтами.

Далее воспользуемся функцией `add_one` из крейта `add_one` в крейте `adder`. Откройте файл _adder/src/main.rs_ и добавьте вверху строку `use`, чтобы включить в область видимости новый крейт библиотеки `add_one`. Затем измените функцию `main`, чтобы она вызывала функцию `add_one`, как показано в листинге 14.7.

Файл: adder/src/main.rs
```rust
use add_one;

fn main() {
    let num = 10;
    println!(
        "Hello, world! {} plus one is {}!",
        num,
        add_one::add_one(num)
    );
}
```
Листинг 14-7: Использование функционала библиотечного крейта `add-one` в крейте `adder`

Давайте соберём рабочее пространство, запустив команду `cargo build` в каталоге верхнего уровня _add_!
```
$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
```
Чтобы запустить бинарный крейт из каталога _add_, нам нужно указать какой пакет из рабочей области мы хотим использовать с помощью аргумента `-p` и названия пакета в команде `cargo run` :
```
$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
```
Первый раздел вывода показывает, что тест `it_works` в крейте `add_one` прошёл. В следующем разделе показано, что в крейте `adder` было найдено ноль тестов, а затем в последнем разделе показано, что в документации крейта `add_one` также было найдено ноль тестов. Выполнение команды `cargo test` в рабочем пространстве структурированном таким образом, будет запускать тесты для всех крейтов в рабочего пространства.

Мы также можем запустить тесты для одного конкретного крейта в рабочем пространстве из каталог верхнего уровня с помощью флага `-p` и указанием имени крейта для которого мы хотим запустить тесты:
```
$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

## [Установка исполняемых крейтов из Crates.io командой `cargo install`](https://doc.rust-lang.ru/book/ch14-04-installing-binaries.html#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D1%85-%D0%BA%D1%80%D0%B5%D0%B9%D1%82%D0%BE%D0%B2-%D0%B8%D0%B7-cratesio-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BE%D0%B9-cargo-install)

Команда `cargo install` позволяет локально устанавливать и использовать исполняемые крейты. Она не предназначена для замены системных пакетов; она используется как удобный способ Rust разработчикам устанавливать инструменты, которыми другие разработчики поделились на сайте [crates.io](https://crates.io/)<!-- <!----> -->. Заметьте, можно устанавливать только пакеты, имеющие исполняемые целевые крейты. _Исполняемой целью_ (binary target) является запускаемая программа, созданная и имеющая в составе крейта файл _src/main.rs_ или другой файл, указанный как исполняемый, в отличии от библиотечных крейтов, которые не могут запускаться сами по себе, но подходят для включения в другие программы. Обычно крейт содержит информацию в файле _README_, является ли он библиотекой, исполняемым файлом или обоими вместе.

Все исполняемые файлы установленные командой `cargo install` сохранены в корневой установочной папке _bin_. Если вы установили Rust с помощью _rustup.rs_ и у вас его нет в пользовательских конфигурациях, то этим каталогом будет _$HOME/.cargo/bin_. Он гарантирует, что каталог находится в вашем окружении `$PATH`, чтобы вы имели возможность запускать программы, которые вы установили командой `cargo install`.

Например, в главе 12 мы упоминали Rust реализацию инструмента `grep` под названием `ripgrep` для поиска файлов. Если мы хотим установить `ripgrep`, мы можем запустить следующее:
```
$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
--snip--
   Compiling ripgrep v11.0.2
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
```

Последняя строка вывода показывает местоположение и название установленного исполняемого файла, который в случае `ripgrep` называется `rg`. Если вашей установочной директорией является `$PATH`, как уже упоминалось ранее, вы можете запустить `rg --help` и начать использовать более быстрый и грубый инструмент для поиска файлов!

## [Расширение Cargo пользовательскими командами](https://doc.rust-lang.ru/book/ch14-05-extending-cargo.html#%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%B8%D0%B5-cargo-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%BC%D0%B8-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%D0%BC%D0%B8)

Cargo спроектирован так, что вы можете расширять его новыми субкомандами без необходимости изменения самого Cargo. Если исполняемый файл доступен через переменную окружения `$PATH` и назван по шаблону `cargo-something`, то его можно запускать как субкоманду Cargo `cargo something`. Пользовательские команды подобные этой также перечисляются в списке доступных через `cargo --list`. Возможность использовать `cargo install` для установки расширений и затем запускать их так же, как встроенные в Cargo инструменты, это очень удобное следствие продуманного дизайна Cargo!

## [Итоги](https://doc.rust-lang.ru/book/ch14-05-extending-cargo.html#%D0%98%D1%82%D0%BE%D0%B3%D0%B8)

Совместное использование кода с Cargo и [crates.io](https://crates.io/) является частью того, что делает экосистему Rust полезной для множества различных задач. Стандартная библиотека Rust небольшая и стабильная, но крейты легко распространять, использовать и улучшать независимо от самого языка. Не стесняйтесь делиться кодом, который был вам полезен, через [crates.io](https://crates.io/); скорее всего, он будет полезен и кому-то ещё!